#!/bin/sh
# Yet Another Graphics Benchmark
# Automated script to measure Win32 graphics performance
# Copyright 2010 Dan Kegel.
# Licence: LGPL (for winehq compatibility)
#
# To run on Windows, please use cygwin.
# When running on Windows Vista or 7, disable UAC and reboot, or Autohotkey won't be able to script the installers.
# On any OS, you'll want to install the packages
#  svn cabextract unzip wget
# and then do something like
#  svn checkout http://winezeug.googlecode.com/svn/trunk/ winezeug
#  cd winezeug
#  sh yagmark 3dmark2000
# On Windows 7, you have to mark the installed 3dmark2000/3dmark2001 executables as needing Windows XP compatibility mode, or they will not run.

WINEPREFIX="${WINEPREFIX:-$HOME/.wine-yagmark}"
export WINEPREFIX

case "$OS" in
 "Windows_NT")
    WINE=""
    DRIVE_C="C:/"
    XXXPATH=cygpath
    # Mysterious workaround for quoting difference between cygwin and linux
    backslash='\'
    ;;
 *)
    WINE=${WINE:-wine}
    DRIVE_C="$WINEPREFIX/drive_c"
    XXXPATH="$WINE winepath"
    # Mysterious workaround for quoting difference between cygwin and linux
    backslash='\\'
    ;;
esac
export WINE

# The folder-name is localized!
programfilesdir_win="`unset WINEDEBUG; WINEDLLOVERRIDES=mshtml= $WINE cmd.exe /c echo "%ProgramFiles%" | tr -d '\015'`"
test x"$programfilesdir_win" != x || die "$WINE cmd.exe /c echo '%ProgramFiles%' returned empty string"
programfilesdir_unix="`unset WINEDEBUG; $XXXPATH -u "$programfilesdir_win" | tr -d '\015' `"
test x"$programfilesdir_unix" != x || die "winepath -u $programfilesdir_win returned empty string"

# 64 bit windows has a second directory for program files
programfilesdir_x86_win="${programfilesdir_win} (x86)"
programfilesdir_x86_unix="${programfilesdir_unix} (x86)"
if ! test -d "$programfilesdir_x86_unix"
then
    programfilesdir_x86_win="${programfilesdir_win}"
    programfilesdir_x86_unix="${programfilesdir_unix}"
fi

YAGMARK_TMP="$DRIVE_C"/yagmarktmp
YAGMARK_TMP_WIN='c:\yagmarktmp'
YAGMARK_RESULTS="$DRIVE_C"/yagmarkresults
YAGMARK_RESULTS_WIN='c:\yagmarkresults'

olddir=`pwd`

rm -rf "$YAGMARK_TMP"
mkdir -p "$YAGMARK_TMP"
mkdir -p "$YAGMARK_RESULTS"

cputype=`cat /proc/cpuinfo | egrep 'model name' | 
        awk '{print $8}' | uniq`

host=`hostname | sed 's/\..*//'`    

case "$OS" in
"Windows_NT")
    systeminfo | tee "$YAGMARK_TMP"/sysinfo.txt
    # Dirty code to simplify os name
    osname=`grep "OS Name" "$YAGMARK_TMP"/sysinfo.txt | sed 's/.*Microsoft.*Windows //;s/VistaT/Vista/;s/ .*//'`
    wineversion=""
    dxdiag -t "$YAGMARK_TMP_WIN"\\dxdiaginfo.txt
    echo "--------------- dxdiag ---------------" >> "$YAGMARK_TMP"/sysinfo.txt
    cat "$YAGMARK_TMP"/dxdiaginfo.txt >> "$YAGMARK_TMP"/sysinfo.txt
    gputype=`grep 'Card name' < "$YAGMARK_TMP"/dxdiaginfo.txt |
            awk '{print $5"_"$6}'`
    ;;
*) 
    # note: next line contains a tab
    osname=`lsb_release -d | sed 's/.*://;s/^[ 	]*//;s/ /_/g'`
    wineversion=`$WINE --version`
    (lspci || /sbin/lspci || /usr/sbin/lspci) > "$YAGMARK_TMP"/sysinfo.txt
    gputype=`cat "$YAGMARK_TMP"/sysinfo.txt | grep VGA |
             sed -e 's/.*\[//;s/]\.*//;s/ (.*//;s/GeForce //;s/ /_/g'`
    
    # Handle case where kernel doesn't know this graphics card by name
    echo gputype is $gputype
    case $gputype in
    *nVidia_Corporation_Device_0ca3) gputype="GT_240";;
    esac
    ;;
esac

# Put wine version last, since it's so long
SYSTEMID1="$cputype-"$gputype"-$osname-$host"
SYSTEMID="$SYSTEMID1-$wineversion"

echo SYSTEMID is $SYSTEMID

#----------------------------------------------------------------

ahk_do()
{
   echo "$@" | sed "s/\$//" > "$YAGMARK_TMP"/tmp.ahk
   $WINE "$programfilesdir_x86_unix/AutoHotkey/AutoHotkey.exe" "$YAGMARK_TMP"/tmp.ahk
}

#----------------------------------------------------------------

do_clear()
{
    rm -f "$YAGMARK_RESULTS"/* 2> /dev/null
}

#----------------------------------------------------------------

run_3dmark2000()
{
    exe_dir="$programfilesdir_x86_unix/MadOnion.com/3DMark2000"

    SAVE_PATH="$YAGMARK_RESULTS_WIN${backslash}3dmark2000"

    # Install if needed
    if ! test -f "$exe_dir/3DMark2000.exe"
    then
        sh wisotool 3dmark2000
    fi
    cd "$exe_dir"
    ahk_do "
        SetTitleMatchMode, 2
        run, .${backslash}3DMark2000.exe
        winwait, 3DMark2000, Welcome
        ; Uncomment these ten lines to do just a tiny benchmark during debugging
        ;ControlClick, New, 3DMark2000, Welcome
        ;sleep 1000
        ;send {escape}
        ;send !fn
        ;send c
        ;winwait, Select Tests
        ;send c
        ;send !p
        ;send {Enter}
        ;sleep 1000
        send b
        winwait, Overall Score
        sleep 1000
        send {ESC}
        winwaitactive, 3DMark2000
        sleep 500
        ; Save it once with default type so we don't get the kamikaze dialog box on exit
        send ^s
        winwait, Save
        send {DEL 8}
        send $SAVE_PATH
        send {Enter}
        ; Save it again with .txt, which is what we really want
        send !fa
        winwait, Save
        send !t3
        send {Enter}
        sleep 500
        send !fx
        sleep 1000
        send n
        WinClose
        sleep 500
        send {Enter}
        WinWaitClose, 3DMark2000
        "
    cd "$YAGMARK_RESULTS"
    # Parse results, add prefix, and make parse-friendly
    sed '1,/Platform/d;
        /Fill Rate/,$d;
        s/^/3dmark2000_/;
        s/[- _][- _]*/_/g;
        s,:,,' 3dmark2000.txt > 3dmark2000.parsed
    if test -s 3dmark2000.parsed
    then
        cat 3dmark2000.parsed
    else
        echo "No results?"
        rm 3dmark2000.parsed
    fi
    cd "$olddir"
}

run_3dmark2001()
{
    exe_dir="$programfilesdir_x86_unix/MadOnion.com/3DMark2001 SE"
    SAVE_PATH="$YAGMARK_RESULTS_WIN${backslash}3dmark2001"

 # Install if needed
    if ! test -f "$exe_dir/3DMark2001SE.exe"
    then
        sh wisotool 3dmark2001
    fi
    cd "$exe_dir"
    ahk_do "
        SetTitleMatchMode, 2
        run, 3DMark2001SE.exe
        winwait, 3DMark2001
        sleep 500
        ; Uncomment next 7 lines to do just a tiny benchmark during debugging
        ;send c
        ;winwait, Select Tests
        ;sleep 500
        ;send c
        ;send f
        ;send {Enter}
        ;sleep 500
        send b
        winwaitactive, Overall Score
        sleep 1000
        send l
        sleep 500
        send ^s
        winwait, Save As
        send {DEL 8}
        send $SAVE_PATH
        send !t3
        send {Enter}
        sleep 500
        send !fx
        sleep 1000
        WinWaitClose, 3DMark2001
        "
    cd "$YAGMARK_RESULTS"
    # Parse results, add prefix, and make parse-friendly
    sed '1,/RESULTS/d;
        /Fill Rate/,$d;
        s/^/3dmark2001_/;
        s/[- _][- _]*/_/g;
        s/_fps/ fps/' 3dmark2001.txt > 3dmark2001.parsed
    if test -s 3dmark2001.parsed
    then
        cat 3dmark2001.parsed
    else
        echo "No results?"
        rm 3dmark2001.parsed
    fi
    cd "$olddir"
}

run_3dmark06()
{
    exe_dir="$programfilesdir_x86_unix/Futuremark/3DMark06"

    SAVE_PATH="$YAGMARK_RESULTS_WIN${backslash}3dmark06"

    # TODO: add an "if workaround_wine_bug" around -nosysteminfo
    ARGS="-nosysteminfo"
    case "$OS" in
    "Windows_NT") ARGS="" ;;
    esac

    # Install if needed
    if ! test -f "$exe_dir/3DMark06.exe"
    then
        sh wisotool 3dmark06
    fi

    cd "$exe_dir"
    ahk_do "
        SetTitleMatchMode, 2
        run, 3DMark06.exe $ARGS
        winwait, Please Register
        sleep 10000
        ;ControlClick, Button3
        send {tab 2}{space}
        winwait, Tip Of The Day
        sleep 500
        send {ESC}
        sleep 500
        send {Enter}
        winwait, 3DMark Score
        sleep 500
        send {tab}
        send {space}
        winwait, Save
        send {DEL 8}
        send $SAVE_PATH
        send {Enter}
        sleep 500
        send {ESC}
        winkill 3DMark06
        "
    cd "$YAGMARK_RESULTS"
    unzip -o 3dmark06.3dr Result.xml
    xmllint --format --nocdata --encode ascii Result.xml |    # convert to ascii and canonicalize
      tr '\012' ' ' |                                         # remove all line breaks
      sed 's,</Result>,|,g;s,</Setting>,|,g' |                # put record separator after each result or setting
      tr '|' '\012' |                                         # turn record separators into line breaks
      sed 's,</Name>,=,g' |                                   # add field separator between variable and value
      sed 's,<Category.*,,' |                                 # remove fields we don't care about
      sed 's,<Plain>[^<]*</Plain>,,g' |                       # remove fields we don't care about
      egrep -v "\.dll|\.exe|Posted|N/A" |                     # remove records we don't care about
      sed 's,<[^>]*>,,g' |                                    # remove remaining tags, leaving just content
      sed 's,^  *,,;s,  *$,,' |                               # remove extra whitespace at start and end of lines
      sed 's, *= *,=,g' |                                     # remove extra whitespace between fields
      sed 's, - , ,' |                                        # make variable names legal identifiers
      sed 's,Anti-Aliasing,AntiAliasing,' |                   # make variable names legal identifiers
      sed 's,post-processing,postprocessing,' |               # make variable names legal identifiers
      sed 's,SM2.0,SM2_0,' |                                  # make variable names legal identifiers
      sed 's,/SM3.0,_SM3_0,' |                                # make variable names legal identifiers
      sed 's, ,_,g' |                                         # make variable names legal identifiers
      tr = '\011' |                                           # use tab as field separator
      grep . > 3dmark06.txt                                   # remove blank lines

    sed 's/^/3dmark06_/' < 3dmark06.txt |                     # add test name to each record
      egrep -v "Frequency|Run_Length|_Profile|Width|Height|_Level|_Quality" > 3dmark06.parsed       # Remove less interesting results and non-results
    cat 3dmark06.parsed
    cd "$olddir"
}

run_re5bench()
{
    exedir="$programfilesdir_x86_unix/CAPCOM/RESIDENT EVIL 5 Benchmark Version"
    exe="$exedir/RE5DX9.EXE"

    # Install if needed
    if ! test -f "$exe"
    then
        sh wisotool re5bench
    fi

    # Can this be scraped/controlled at all with autohotkey?  Maybe if run in window...
    cd "$exedir"
    $WINE "$exe"
    cd "$olddir"
}

run_unigine_heaven()
{
    exedir="$programfilesdir_x86_unix/Unigine/Heaven"
    exe="$exedir/Heaven_d3d9.bat"
    commandline="./Heaven.exe -extern_define RELEASE,BENCHMARK -engine_config data/heaven_2.0.cfg -data_path ./ -video_app direct3d9 -sound_app openal "

    # Install if needed
    if ! test -f "$exe"
    then
        sh wisotool unigine_heaven
    fi

    cd "$exedir"
    $WINE $commandline > "$YAGMARK_RESULTS"/heaven2.log 2>&1
    cd "$YAGMARK_RESULTS"
    egrep -v 'fixme|connection' < heaven2.log | uniq > heaven2.txt
    cat heaven2.txt | 
        egrep ":[ 	]" |                  # ignore non key/value lines
        grep -v " path:" |                    # ignore uninteresting records
        sed 's/  */ /g' |                     # remove runs of spaces
        tr ' ' _ |                            # make key names legal identifiers
        sed 's/:[_	]/	/' |          # use tab as field separator
        sed 's/^/heaven2_/' > heaven2.parsed  # add test name to each record
    cd "$olddir"
}

announce()
{
   echo ">> $*"
   eval $1 $2 $3 $4 $5 $6 $7 $8 $9
}

do_system_description()
{
    echo ">>-------- begin system description ---------"
    echo "Host Name: $host"
    echo "CPU Type: $cputype"
    echo "Graphics Card: $gputype"
    echo "Operating System: $osname"
    echo "Wine Version: $wineversion"

    cat "$YAGMARK_TMP"/sysinfo.txt

    case "$OS" in
    "Windows_NT")
        ;;
    *)
       announce glxinfo \| egrep 'vendor\|renderer\|version'
       announce dmesg \| grep NVIDIA | grep loading | tail -n 1
    ;;
    esac
    echo ">>-------- end system description ---------"
}

do_report()
{
    echo ">>-------- begin yagmark report ---------"
    announce date
    echo ">>-------- begin summary ---------"
    for file in "$YAGMARK_RESULTS"/*.parsed
    do
       cat $file
    done
    echo ">>-------- end summary ---------"
    for file in "$YAGMARK_RESULTS"/*.txt
    do
       echo ">>-------- begin $file ---------"
       tr -d '\000' < "$file"
       echo ">>-------- end $file ---------"
    done

    do_system_description

    echo ">>-------- end yagmark report ---------"
}

# Compute median
# Input and output are lines of form 'variable value'.
# Multiple lines with same variable represent different measurements.
# Replaces all the lines for a particular variable
# with one containing the median of all measurements for that variable.
median()
{
    # Sort first by variable name...
    sort | perl -e '
        sub report { 
            return if !@vals;
            # ... then sort all values for variable, and take the middle one.
            @sorted = sort { $a - $b; } @vals; 
            print $oldvar."\t".$sorted[@sorted/2]."\n";
            undef @vals;
        }
        while (<STDIN>) {
            ($var,$val)=split(" ");
            report() if ($var ne $oldvar);
            push(@vals, $val);
            $oldvar=$var;
        }
        report();
    '
}

# Show statistics over all results from given system
do_stats()
{
    dir="$1"
    for file in $dir/*.txt
    do
        sed '1,/begin summary/d;/end summary/,$d' < $file | grep '[ 	]-*[0-9]'
    done | median 
}

# Read all results/*/stats.dat files for this system, compute the rank across all
# such files of each measurement, and create a corresponding results/*/stats.dat.rank 
# with the same first two columns (var, val) and a new third column (rank/total).
# This is intended to be useful when watching for performance regressions;
# they should show up as bad ranks
# (for FPS or score variables, rank of 1 is great, rank of N is awful).
run_rank()
{
    cd results

    # Clear all output files (since we build them up by appending)
    rm -f $SYSTEMID1*/stats.dat.rank 2> /dev/null

    # For each variable in the input data files for this system,
    for var in `awk '{print $1}' $SYSTEMID1*/stats.dat | sort -u`
    do
        awk "\"$var\"==\$1 {print FILENAME, \$2}" $SYSTEMID1*/stats.dat |   # Show values from all input files for that var
          sort -rn -k +2 |                                                  # Sort them numerically, highest first
          nl > "$YAGMARK_TMP"/sorted.dat                                    # Add a rank column (highest value = rank 1)
        n=`wc -l < "$YAGMARK_TMP"/sorted.dat`                               # Note what the lowest rank is
        awk "{print \"$var\", \$3, \$1\"/\"$n >> \$2\".rank\"}" \           # Generate line for this var in all output files
            < "$YAGMARK_TMP"/sorted.dat
    done
    cd $olddir
}

# TODO: add a wisotool-style menu

do_clear

for cmd
do
   echo running run_$cmd
   run_$cmd
done

mkdir -p results/"$SYSTEMID"
if test `find "$YAGMARK_RESULTS" -type f | wc -l` -gt 0
then
    mkdir -p results/"$SYSTEMID"
    do_report > results/"$SYSTEMID"/"$SYSTEMID"-`date +%F-%H.%M`.txt
    echo "New medians in results/$SYSTEMID/stats.dat":
    do_stats results/"$SYSTEMID" | tee results/"$SYSTEMID"/stats.dat
fi

