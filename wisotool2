#!/bin/sh
# LGPL
# Copyright 2010 Dan Kegel
# Experimental cleanup of wisotool
#
#--------------------------------------------------------------------
# See http://code.google.com/p/winezeug/wiki/ConvergedFrontends
#
# Coding standards:
# Languge:
# - Portability matters, as this script is run on many operating systems
# - No bash, zsh, or csh extensions
# - Prefer classic sh idioms
#
# Portability:
# - If there is no universally available program for a needed function,
#   support the two most frequently available programs.
#   e.g. fall back to wget if curl is not available; likewise, support
#   both sha1sum and openssl.
#
# Formatting:
# - Your terminal and editor must be configured for utf-8
# - Do not use tabs in this file or any verbs.
# - Indent 4 spaces.
# - Curlies and 'then' at beginning of line.
# - cases aligned with 'case' and 'esac'
# - Try to keep line length below 80 (makes printing easier)
#
# Commenting:
# - Comments should explain intent in English
# - Keep functions short and well named to reduce need for comments
#
# Naming:
# Public things defined by this script, for use by verbs:
# - Variables have uppercase names starting with W_
# - Functions have lowercase names starting with w_
# Private things internal to this script, not for use by verbs: 
# - Local variables have lowercase names starting with uppercase _W_
# - Global variables have uppercase names starting with WISOTOOL_
# - Functions have lowercase names starting with wisotool_
#
# Internationalization / localization:
# - Each important or frequently used message must be localized to at
#   least one non-English language.  The default language presented
#   if no translation is available for a message should be English.
#
#--------------------------------------------------------------------

# Name of this version of wisotool (YYYYMMDD)
WISOTOOL_VERSION=20101124

#---- Public Functions ----

# Display warning message
w_warn()
{
    echo "------------------------------------------------------"
    echo "$@"
    echo "------------------------------------------------------"

    # For some reason, nulls were showing up in $@?!, causing truncated output in zenity
    msg="`echo $@ | tr '\000' ' '`"
    case $WISOTOOL_MENU in
    zenity) zenity --error --title=Wisotool --text="$msg" --no-wrap;;
    kdialog) kdialog --title Wisotool --error "$msg" ;;
    none) ;;
    esac
}

# Display fatal error message
w_die()
{
    w_warn "$@"

    exit 1
}

# Execute with error checking
w_try()
{
    # "VAR=foo try cmd" fails to put VAR in the environment
    # with some versions of bash if try is a shell function?!
    # Adding this explicit export works around it.
    export WINEDLLOVERRIDES
    echo Executing "$@"
    # Mark executable - needed if running on windows vista
    case "$1" in
    *.exe) chmod +x "$1" || true
      cmd /c "$@"
      ;;
    *)
      "$@"
      ;;
    esac
    status=$?
    if test $status -ne 0
    then
        w_die "Note: command '$@' returned status $status.  Aborting."
    fi
}

w_try_regedit()
{
    # on windows, doesn't work without cmd /c
    case "$OS" in
    "Windows_NT") cmdc="cmd /c";;
    *) unset cmdc
    esac

    w_try wisotool_early_wine $cmdc regedit "$@"
}

w_try_winetricks()
{
    w_try "$WISOTOOL_WINETRICKS" -q $*
}

w_read_key()
{
    case "$W_OPT_UNATTENDED" in
    0) W_KEY=dummy_to_make_autohotkey_happy ; return 0 ;;
    esac

    _W_keyfile="$W_CACHE/$W_PACKAGE/key.txt"
    if ! test -f "$_W_keyfile"
    then
        # read key from user
        case $LANG in
        de*) _W_keymsg="Bitte einen Key für Pakete '$W_PACKAGE' eingeben"
            _W_nokeymsg="Keinen Key eingegeben?"
            ;;
        *)  _W_keymsg="Please enter the key for app '$W_PACKAGE'"
            _W_nokeymsg="No key given"
            ;;
        esac
        case $WISOTOOL_MENU in
        *zenity) W_KEY=`zenity --entry --text "$_W_keymsg"` ;;
        *kdialog) W_KEY=`kdialog --inputbox "$_W_keymsg"` ;; 
        *xmessage) w_die "sorry, can't read key from gui with xmessage" ;;
        esac
        if test "$W_KEY" = ""
        then
            w_die "$_W_nokeymsg"
        fi
        echo "$W_KEY" > "$_W_keyfile"
    fi
    W_KEY=`cat "$_W_keyfile" | tr -d -`
    unset _W_keyfile _W_keymsg _W_nokeymsg
}

# Convert a Unix path to a Windows path
# Usage is lowest common denominator of cygpath/winepath
# so -u to convert to unix, and -w to convert to windows
w_pathconv()
{
    case "$OS" in
     "Windows_NT")
        cygpath "$@"
        ;;
     *)
        wisotool_early_wine winepath "$@"
        ;;
    esac
}

# verify an sha1sum
w_verify_sha1sum()
{
    _W_vs_wantsum=$1
    _W_vs_file=$2

    _W_vs_gotsum=`$WISOTOOL_SHA1SUM < $_W_file | sed 's/ .*//'`
    if [ "$_W_vs_gotsum"x != "$_W_wantsum"x ]
    then
       w_die "sha1sum mismatch!  Rename $_W_vs_file and try again."
    fi
    unset _W_vs_wantsum _W_vs_file _W_vs_gotsum
}

# Download a file
# Usage: w_download url [sha1sum [filename [cookie jar]]]
# Caches downloads in wisotoolcache/$package
w_download()
{
    url="$1"
    sum="$2"
    file="$3"
    cookiejar="$4"

    if [ "$file"x = ""x ]
    then
        file=`basename "$url"`
    fi
    cache="$W_CACHE/$W_PACKAGE"
    mkdir -p "$cache"
    if test ! -s "$cache/$file" && test -f "$cache/$file"
    then
        # zero size - bad download?
        rm "$cache/$file"
    fi
    if test "$nosizecheck" != "" || test ! -f "$cache/$file" || test "$WISOTOOL_CONTINUE_DOWNLOAD"
    then
        cd "$cache"
        # Mac folks tend to have curl rather than wget
        # On Mac, 'which' doesn't return good exit status
        # Need to jam in --header "Accept-Encoding: gzip,deflate" else
        # redhat.com decompresses liberation-fonts.tar.gz!
        echo Downloading $url
        if [ -x "`which wget 2>/dev/null`" ]
        then
           # Use -nd to insulate ourselves from people who set -x in WGETRC
           # [*] --retry-connrefused works around the broken sf.net mirroring
           # system when downloading corefonts
           # [*] --read-timeout is useful on the adobe server that doesn't
           # close the connection unless you tell it to (control-C or closing
           # the socket)
           # Disable retries for gog.com (which requires higher level retries)
           wget -O "$file" -nd -c --read-timeout=300 --tries=1 --retry-connrefused --header "Accept-Encoding: gzip,deflate" ${cookiejar:+--load-cookies "$cookiejar"} "$url"
        else
           # curl doesn't get filename from the location given by the server!
           # fortunately, we know it
           curl -L -o "$file" -C - --header "Accept-Encoding: gzip,deflate" ${cookiejar:+--cookie "$cookiejar"} "$url"
        fi
        if test $? != 0
        then
            test -f "$file" && rm "$file"
            w_die "Downloading $url failed"
        fi
        # Need to decompress .exe's that are compressed, else cygwin fails
        # Only affects cygwin, so don't barf if 'file' not installed
        FILE=`which file 2>/dev/null`
        case $FILE-$file in
        /*-*.exe)
            case `file $file` in
            *gzip*) mv $file $file.gz; gunzip < $file.gz > $file;;
            esac
        esac

        # On cygwin, .exe's must be marked +x
        case $file in
        *.exe) chmod +x $file ;;
        esac

        if [ "$sum"x != ""x ]
        then
            w_verify_sha1sum $sum "$cache/$file"
        fi
    fi
}

w_download_manual()
{
    _W_url="$1"
    _W_file="$2"
    _W_sha1sum="$3"

    case $LANG in
    de*) _W_dlmsg="Bitte laden Sie $_W_file von $_W_url runter, stellen Sie's in $W_CACHE/$W_PACKAGE, dann wiederholen Sie diesen Kommando.";;
    *) _W_dlmsg="Please download $_W_file from $_W_url, place it in $W_CACHE/$W_PACKAGE, then re-run this script.";;
    esac

    if ! test -f "$W_CACHE/$W_PACKAGE/$_W_file"
    then
        mkdir -p "$W_CACHE/$W_PACKAGE"
        xdg-open "$_W_url"
        sleep 3   # give some time for browser to open
        w_die "$_W_dlmsg"
        # FIXME: wait in loop until file is finished?
    fi
    # FIXME: verify $sha1sum of $file
    unset _W_url _W_file _W_sha1sum _W_dlmsg
}

# Usage: w_mount "volume name"
# FIXME: should take mount option 'unhide' for poorly mastered discs
w_mount()
{
    WISOTOOL_IMG="$W_CACHE/$W_PACKAGE/$1.iso"
    mkdir -p "$W_CACHE/$W_PACKAGE"

    if test -f "$WISOTOOL_IMG"
    then
        wisotool_mount_cached_iso "$1" 
    else
        case "$WISOTOOL_OPT_SAVE" in
        0)
            wisotool_mount_real_volume "$1"
            ;;
        1)
            wisotool_cache_iso "$1" 
            wisotool_mount_cached_iso "$1" 
            ;;
        esac
    fi
}

w_umount()
{
    if test "$WINE" = ""
    then
        w_die Windows not yet supported
    else
        echo "Running $WISOTOOL_SUDO umount $WISOTOOL_ISO_MOUNT_ROOT"
        case "$WISOTOOL_SUDO" in
        gksudo)
          # -l lazy unmount in case executable still running
          $WISOTOOL_SUDO "umount -l $WISOTOOL_ISO_MOUNT_ROOT"
          w_try $WISOTOOL_SUDO "rm -rf $WISOTOOL_ISO_MOUNT_ROOT"
          ;;
        *)
          $WISOTOOL_SUDO umount -l $WISOTOOL_ISO_MOUNT_ROOT
          w_try $WISOTOOL_SUDO rm -rf $WISOTOOL_ISO_MOUNT_ROOT
          ;;
        esac
        rm -f "$WINEPREFIX"/dosdevices/${W_ISO_MOUNT_LETTER}:
        rm -f "$WINEPREFIX"/dosdevices/${W_ISO_MOUNT_LETTER}::
    fi
}

w_ahk_do() {
   load_autohotkey
   _W_CR=`printf \\\\r`
   echo "$@" | sed "s/\$/$CR/" > "$W_TMP"/tmp.ahk
   $WINE "$W_PROGRAMS_X86_UNIX/AutoHotkey/AutoHotkey.exe" "$W_TMP_WIN"\\tmp.ahk
   unset _W_CR
}

load_autohotkey()
{
    test -f "$W_PROGRAMS_X86_UNIX/AutoHotkey/AutoHotkey.exe" || w_try_winetricks autohotkey
}

# Usage: workaround_wine_bug bugnumber [good-wineversion-shell-pattern]
# False (nonzero status) on Windows.
# True (zero status) on Wine unless good-wineversion-shell-pattern is set
# and matches the current wine version.
# For debugging: if you want to skip a bug's workaround, put the bug number in the
# environment variable WISOTOOL_BLACKLIST to disable it.
w_workaround_wine_bug()
{
    if test "$WINE" = ""
    then
        echo No need to work around wine bug $1 on windows
        return 1
    fi
    # FIXME: accept wine version number as $2, only apply if before that
    case $1 in
    "$WISOTOOL_BLACKLIST")
        echo wine bug $1 workaround blacklisted, skipping
        return 1
        ;;
    esac
    case $LANG in
    de*) w_warn "Wine-Fehler $1 wird umgegangen" ;;
    *)   w_warn "Working around wine bug $1" ;;
    esac
    return 0
}

# Function for verbs to register themselves so they show up in the menu.
# Example:
# w_metadata  wog \
#   title="World of Goo Demo" \
#   pub="2D Boy" \
#   year="2008" \
#   media="download" \
#   file1="WorldOfGooDemo.1.0.exe"

w_metadata()
{
   file="$WISOTOOL_METADATA/$1.vars"
   shift
   # FIXME: fall back to posix shell string manipulation if perl not present?
   perl -e 'for (@ARGV) { if (/(\w*)=(.*)/) { print "$1=\"$2\"\n"; } else { die "bad parameter $_" } }' "$@" > "$file"
}

# Function for verbs to register their main executable.
# Example:
#   w_declare_exe "$W_PROGRAMS_X86_WIN\\WorldOfGooDemo" WorldOfGoo.exe
w_declare_exe()
{
    _W_dir="$1"
    _W_exe="$2"
    cat > "$W_DRIVE_C/run-$W_PACKAGE.bat" <<__EOF__
${W_PROGRAMS_DRIVE}:
cd "$_W_dir"
$_W_exe
__EOF__
    unset _W_dir _W_exe
}

#---- Private Functions ----

wisotool_print_version() {
    echo "$WISOTOOL_VERSION"
}

# Run a windows command without triggering wine's mshtml's gecko install dialog
wisotool_early_wine()
{
    WINEDEBUG=-all WINEDLLOVERRIDES=mshtml= $WINE "$@"
}

wisotool_detect_gui()
{
    if test -x "`which zenity 2>/dev/null`"
    then
        WISOTOOL_MENU=zenity
    elif test -x "`which kdialog 2>/dev/null`"
    then
        echo "Zenity not found!  Using kdialog as poor substitute."
        WISOTOOL_MENU=kdialog
    else
        echo "Please install zenity if you want a graphical interface."
        exit 1
    fi
}

# Detect which sudo to use
wisotool_detect_sudo()
{
    WISOTOOL_SUDO=sudo
    if test "$WISOTOOL_MENU" = "none"
    then
        return
    fi
    if test x"$DISPLAY" != x""
    then
        if test -x "`which gksudo 2>/dev/null`"
        then
            WISOTOOL_SUDO=gksudo
        elif test -x "`which kdesudo 2>/dev/null`"
        then
            WISOTOOL_SUDO=kdesudo
        fi
    fi
}

# Output list of verbs to execute to stdout
wisotool_showmenu()
{
    case $WISOTOOL_MENU in
    zenity)
        case $LANG in
        de*) echo -n "zenity \
                --title 'Pakete auswählen' \
                --text 'Welche Pakete möchten Sie installieren?' \
                --list \
                --checklist \
                --column '' \
                --column Paket \
                --column Name \
                --column Herausgeber \
                --column Jahr \
                --column Media \
                --height 500 \
                --width 800 \
                " 
             ;;
        *) echo -n "zenity \
                --title 'Select a package to install' \
                --text 'Which package(s) would you like to install?' \
                --list \
                --checklist \
                --column '' \
                --column Package \
                --column Title \
                --column Publisher \
                --column Year \
                --column Media \
                --height 500 \
                --width 800 \
                " 
             ;;
        esac > "$WISOTOOL_WORKDIR"/zenity.sh

        for metadatafile in "$WISOTOOL_METADATA"/*.vars
        do
            code=`basename $metadatafile .vars`
            (
            title='?'
            author='?'
            . $metadatafile
            echo -n " " FALSE \
                    $code \
                    "\"$title\"" \
                    "\"$publisher\"" \
                    "\"$year\"" \
                    "\"$media\""
            )
        done >> $WISOTOOL_WORKDIR/zenity.sh

        sh "$WISOTOOL_WORKDIR"/zenity.sh | tr '|' ' '
        ;;

    kdialog)
        w_die "unimplemented"
        ;;
    esac
}

# Returns true if given verb has been registered
wisotool_metadata_exists()
{
   file="$WISOTOOL_METADATA/$1.vars"
   test -f "$file"
}

# List verbs which are already fully cached locally
wisotool_list_cached()
{
    for _W_metadatafile in "$WISOTOOL_METADATA"/*.vars
    do
        (
        code=`basename $_W_metadatafile .vars`
        . $_W_metadatafile
        # FIXME: also check file2... if given
        if test -f "$W_CACHE/$code/$file1"
        then
            echo $code
        fi
        )
    done
    unset _W_metadatafile
}

# List verbs which are downloadable, regardless of whether they're cached yet
wisotool_list_download()
{
    (
        cd "$WISOTOOL_METADATA"
        grep -l 'media=.download' *.vars | sed 's/\.vars//'
    )
}

# Abort if user doesn't own the given directory (or its parent, if it doesn't exist yet)
wisotool_die_if_user_not_dirowner()
{
    if test -d "$1"
    then
        _W_checkdir="$1"
    else
        # fixme: quoting problem?
        _W_checkdir=`dirname "$1"`
    fi
    _W_nuser=`id -u`
    _W_nowner=`ls -l -n -d -L "$_W_checkdir" | awk '{print $3}'`
    if test x$_W_nuser != x$_W_nowner
    then
        w_die "You (`id -un`) don't own $_W_checkdir.  Don't run this tool as another user!"
    fi
}

wisotool_volname()
{
    x=`volname $1 | sed 's/  *$//'`
    if test "x$x" = "x"
    then
        # UDF?  See the ubuntu bug filed against volname
        # FIXME: test this with more than one DVD, that offset 
        # probably varies
        x=`dd if=$1 skip=65562 bs=1 count=28 | tr -d '\000'`
    fi
    echo $x
}

# Really, should take a volume name as argument, and use 'mount' to get 
# mount point if system automounted it.
wisotool_detect_optical_drive()
{
    case "$WISOTOOL_DEV" in
    "") ;;
    *) return ;;
    esac

    for WISOTOOL_DEV in /dev/cdrom /dev/dvd /dev/sr0
    do
        test -b $WISOTOOL_DEV && break
    done

    case "$WISOTOOL_DEV" in
    "x") w_die "can't find cd/dvd drive" ;;
    esac
}

wisotool_cache_iso()
{
    # WISOTOOL_IMG has already been set by w_mount
    _W_expected_volname="$1"

    wisotool_die_if_user_not_dirowner "$W_CACHE"
    wisotool_detect_optical_drive

    # Horrible hack for Gentoo - make sure we can read from the drive
    if ! test -r $WISOTOOL_DEV
    then
        case "$WISOTOOL_SUDO" in
        gksudo) $WISOTOOL_SUDO "chmod 666 $WISOTOOL_DEV" ;;
        *) $WISOTOOL_SUDO chmod 666 $WISOTOOL_DEV ;;
        esac
    fi

    while true
    do
        # Wait for user to insert disc.  
        # Sleep long to make it less likely to close the drive during insertion.
        while ! dd if=$WISOTOOL_DEV of=/dev/null count=1
        do
            sleep 5
        done

        # Some distros automount discs in /media, take advantage of that
        if test -d "/media/_W_expected_volname"
        then
            break
        fi
        # Otherwise try and read it straight from unmounted volume
        _W_volname=`wisotool_volname $WISOTOOL_DEV`
        if test "$_W_expected_volname" != "$_W_volname"
        then
            case $LANG in
            de*)  w_warn "Falsche Disk [$_W_volname] eingelegt.  Bitte legen Sie Disk [$_W_expected_volname] ein!" ;;
            *)    w_warn "Wrong disc [$_W_volname] inserted.  Please insert disc [$_W_expected_volname]" ;;
            esac

            sleep 5
        else
            break
        fi
    done

    # Copy disc to .iso file, display progress every 5 seconds
    # Use conv=noerror,sync to replace unreadable blocks with zeroes
    case $WISOTOOL_OPT_DD in
    dd)
      dd if=$WISOTOOL_DEV of="$W_CACHE"/temp.iso bs=2048 conv=noerror,sync &
      WISOTOOL_DD_PID=$!
      ;;
    ddrescue)
      if test "`which ddrescue`" = ""
      then
          w_die "Please install ddrescue first."
      fi
      ddrescue -v -b 2048 $WISOTOOL_DEV "$W_CACHE"/temp.iso &
      WISOTOOL_DD_PID=$!
      ;;
    esac

    # Note: if user presses ^C, wisotool_cleanup will call wisotool_iso_cleanup
    while ps -p $WISOTOOL_DD_PID > /dev/null 2>&1
    do
      sleep 5
      ls -l "$W_CACHE"/temp.iso
    done
    unset WISOTOOL_DD_PID

    mv "$W_CACHE"/temp.iso "$WISOTOOL_IMG"

    eject $WISOTOOL_DEV || true    # punt if eject not found (as on cygwin)
}

wisotool_mount_cached_iso()
{
    # On entry, WISOTOOL_IMG is already set
    w_umount

    if test "$WINE" = ""
    then
        w_die Windows not yet supported
    else
        # Linux
        # FIXME: find a way to mount or copy from image without sudo
        _W_USERID=`id -u`
        case "$WISOTOOL_SUDO" in
        gksudo)
          w_try $WISOTOOL_SUDO "mkdir -p $WISOTOOL_ISO_MOUNT_ROOT"
          w_try $WISOTOOL_SUDO "mount -o ro,loop,uid=$_W_USERID,unhide $WISOTOOL_IMG $WISOTOOL_ISO_MOUNT_ROOT"
          ;;
        *)
          w_try $WISOTOOL_SUDO mkdir -p $WISOTOOL_ISO_MOUNT_ROOT
          w_try $WISOTOOL_SUDO mount -o ro,loop,uid=$_W_USERID,unhide "$WISOTOOL_IMG" $WISOTOOL_ISO_MOUNT_ROOT
          ;;
        esac

        echo "Mounting as drive ${W_ISO_MOUNT_LETTER}:"
        # Gotta provide a symlink to the raw disc, else installers that check volume names will fail
        rm -f "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"*
        ln -sf "$WISOTOOL_IMG" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}::"
        ln -sf "$WISOTOOL_ISO_MOUNT_ROOT" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"
        unset _W_USERID
    fi
}

wisotool_mount_real_volume()
{
    # Wait for user to insert disc.  
    # For now, only support distros that automount

    case $LANG in
    de*)_W_mountmsg="Disc '$1' bitte einlegen und montieren (für Pakete '$W_PACKAGE')" ;;
    *)  _W_mountmsg="Please insert and mount volume '$1' (needed for package '$W_PACKAGE')" ;;
    esac

    if test "$WINE" = ""
    then
        w_die Windows not yet supported
    else
        while ! test -d "/media/$1"
        do
            w_warn "$_W_mountmsg"
            ls /media
            sleep 1
        done

        wisotool_detect_optical_drive

        # Gotta provide a symlink to the raw disc, else installers that check volume names will fail
        rm -f "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"*
        ln -sf "$WISOTOOL_DEV" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}::"
        ln -sf "/media/$1" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"
    fi

    # FIXME: need to remount some discs with unhide option, 
    # add that as option to w_mount

    unset _W_mountmsg
}

wisotool_cleanup()
{
    test "$W_CACHE_SYMLINK" && rm -f "$W_CACHE_SYMLINK"
    rm -rf "$WISOTOOL_WORKDIR"
}

wisotool_kill_handler()
{
    echo "Caught signal, cleaning up."
    case "$WISOTOOL_DD_PID" in
    "") ;;
    *) kill $WISOTOOL_DD_PID ;;
    esac
    wisotool_cleanup
    echo "Done cleanup, quitting."
    exit 1
}

wisotool_init()
{
    #---- Private Variables ----

    # Ephemeral files for this run
    WISOTOOL_WORKDIR=/tmp/w.$LOGNAME.$$
    rm -rf "$WISOTOOL_WORKDIR"

    # Registering a verb creates a file in WISOTOOL_METADATA
    WISOTOOL_METADATA="$WISOTOOL_WORKDIR/metadata"
    mkdir -p "$WISOTOOL_METADATA"

    # Delete work directory after each run
    trap wisotool_kill_handler 1 2 3 6

    # Which GUI helper to use (none/zenity/kdialog).  See wisotool_detect_gui.
    WISOTOOL_MENU=none

    WISOTOOL_DIR=${WISOTOOL_DIR:-$HOME/.local/wisotool}

    # Overridden for windows
    WISOTOOL_ISO_MOUNT_ROOT=/mnt/wisotool
    W_ISO_MOUNT_LETTER=i

    # Whether to always cache cached iso's (1) or only use cache if present (0)
    # Can be inherited from environment or set via -c, defaults to off
    WISOTOOL_OPT_SAVE=${WISOTOOL_OPT_SAVE:-0}

    # what program to use to make disc image (dd or ddrescue)
    WISOTOOL_OPT_DD=${WISOTOOL_OPT_DD:-dd}

    # Mac folks tend to not have sha1sum, but we can make do with openssl
    if [ -x "`which sha1sum 2>/dev/null`" ]
    then
       WISOTOOL_SHA1SUM="sha1sum"
    elif [ -x "`which openssl 2>/dev/null`" ]
    then
       WISOTOOL_SHA1SUM="openssl dgst -sha1"
    else
       w_die "No sha1sum utility available."
    fi

    #---- Public Variables ----

    # System-specific variables
    case "$OS" in
     "Windows_NT")
        WINE=""
        W_DRIVE_C="C:/"
        ;;
     *)
        WINE=${WINE:-wine}
        WINEPREFIX="${WINEPREFIX:-$HOME/.wine}"
        W_DRIVE_C="$WINEPREFIX/dosdevices/c:"
        ;;
    esac
    # Verbs can rely on W_TMP being empty at entry, deleted after return, and a subdir of C:
    W_TMP="$W_DRIVE_C/windows/temp"
    W_TMP_WIN="C:\\windows\\temp"

    # Where application installers are cached
    # FIXME: move those tr's and sed's into w_pathconv, if they're still needed?
    W_CACHE="${W_CACHE:-$WISOTOOL_DIR/cache}"
    W_CACHE_WIN="`w_pathconv -w $W_CACHE | tr '\012' ' ' | sed 's/ $//'`"

    # The folder-name is localized!
    W_PROGRAMS_WIN="`unset WINEDEBUG; WINEDLLOVERRIDES=mshtml= $WINE cmd.exe /c echo "%ProgramFiles%" | tr -d '\015'`"
    case "$W_PROGRAMS_WIN" in
    "") w_die "$WINE cmd.exe /c echo '%ProgramFiles%' returned empty string" ;;
    %*) w_die "$WINE cmd.exe /c echo '%ProgramFiles%' returned unexpanded string... do you own the parent of $WINEPREFIX ?" ;;
    esac
    # FIXME: move that tr into w_pathconv, if it's still needed?
    W_PROGRAMS_UNIX="`w_pathconv -u "$W_PROGRAMS_WIN" | tr -d '\015' `"

    # 64 bit windows has a second directory for program files
    W_PROGRAMS_X86_WIN="${W_PROGRAMS_WIN} (x86)"
    W_PROGRAMS_X86_UNIX="${W_PROGRAMS_UNIX} (x86)"
    if ! test -d "$W_PROGRAMS_X86_UNIX"
    then
        W_PROGRAMS_X86_WIN="${W_PROGRAMS_WIN}"
        W_PROGRAMS_X86_UNIX="${W_PROGRAMS_UNIX}"
    fi

    # FIXME: don't hardcode
    W_PROGRAMS_DRIVE=c

    # Whether to automate installs (0=no, 1=yes)
    W_OPT_UNATTENDED=${W_OPT_UNATTENDED:-0}

    WISOTOOL_WINETRICKS="$WISOTOOL_SRCDIR/winetricks"
    if ! test -f "$WISOTOOL_WINETRICKS"
    then
        WISOTOOL_WINETRICKS="$W_CACHE/winetricks/winetricks"
        W_PACKAGE=winetricks w_download http://kegel.com/wine/winetricks
    fi

    # Handle case where z: doesn't exist
    case "$W_CACHE_WIN" in
    ""|*\?\\unix*)
        # W_CACHE isn't accessible via a drive letter mapping, so make one,
        # but be sure to clean it up later.
        for letter in y x w v u t s r q
        do
            if ! test -d "$WINEPREFIX"/dosdevices/${letter}:
            then
                WISOTOOL_CACHE_SYMLINK="$WINEPREFIX"/dosdevices/${letter}:
                ln -sf "$W_CACHE" "$WISOTOOL_CACHE_SYMLINK"
                W_CACHE_WIN=${letter}:
                break
            fi
        done
        ;;
    esac
}

wisotool_usage()
{
    case $LANG in
    de*)
        cat <<_EOF_
Usage: $0 [options] [verb|path-to-verb] ...
Angegebene Verben ausführen.
Jeder Verb installiert z.B. eine Anwendung oder ändert eine Einstellung.
Optionen:
-s|--save_isos: isos local speichern (erlaubt spätere Installierung ohne Disk)
-q|--unattended: keine Fragen stellen, alles automatisch installieren
-r|--ddrescue: alternative Zugriffsmodus (hilft bei gekratzten Disks)
-v|--verbose: alle ausgeführten Kommandos anzeigen
-V|--version: Programmversion anzeigen
-h|--help: diese Hilfemeldung anzeigen
Sonstige Verben:
list-cached: Anwendungen mit schon gecachte Installers auflisten
list-download: herunterladbare Anwendungen auflisten
_EOF_
        ;;
    *)
        cat <<_EOF_
Usage: $0 [options] [verb|path-to-verb] ...
Executes given verbs.  Each verb installs an application or changes a setting.
Options:
-s|--save_isos: cache isos (allows later installation without disc)
-q|--unattended: don't ask any questions, just install automatically
-r|--ddrescue: alternate method of disc access (helps with scratched discs)
-v|--verbose: echo all commands as they are executed
-V|--version: display version and exit
-h|--help: display this message and exit
Miscelaneous verbs:
list-cached: list applications with already-cached installers
list-download: list downloadable applications
_EOF_
        ;;
    esac
}

wisotool_handle_option()
{
    case "$1" in
    -r|--ddrescue) WISOTOOL_OPT_DD=ddrescue ;;
    -s|--save_isos) WISOTOOL_OPT_SAVE=1 ;;
    -q|--unattended) W_OPT_UNATTENDED=1 ;;
    -v|--verbose) set -x ;;
    -V|--version) wisotool_print_version ; exit 0;;
    -h|--help) wisotool_usage ; exit 0 ;;
    -*) w_die "unknown option $1" ;;
    *) return 1 ;;
    esac
    return 0
}

# Must initialize variables before calling w_metadata
if ! test "$WISOTOOL_LIB"
then
    WISOTOOL_SRCDIR=`dirname $0`
    WISOTOOL_SRCDIR=`cd $WISOTOOL_SRCDIR; /bin/pwd`

    # Handle options before init, to avoid starting wine for --help or --version
    while wisotool_handle_option $1
    do
        shift
    done

    wisotool_init
fi

#---- Builtin Verbs ----

#----------------------------------------------------------------

w_metadata  blobby_volley \
   title="Blobby Volley" \
   publisher="Daniel Skoraszewsky" \
   year="2000" \
   media="download" \
   file1="blobby.zip"

load_blobby_volley()
{
    w_download_manual http://www.chip.de/downloads/Blobby-Volley_12990993.html blobby.zip c7057c77a5009a88d9d877e17a63b5536ebeb177

    mkdir -p "$W_DRIVE_C/BlobbyVolley"
    cd "$W_CACHE/$W_PACKAGE"
    w_try unzip blobby.zip -d "$W_DRIVE_C/BlobbyVolley"
    w_declare_exe "c:\\BlobbyVolley" "volley.exe"

    if w_workaround_wine_bug 4432
    then
        w_warn "You may need to apply a patch, see http://bugs.winehq.org/show_bug.cgi?id=4432#c15"
    fi
}

#----------------------------------------------------------------

w_metadata singularity \
    title=Singularity \
    publisher=Activision \
    year=2010 \
    media=dvd \
    file1=SNG_DVD.iso

load_singularity()
{
    w_read_key
    w_mount SNG_DVD

    w_ahk_do "
        run ${W_ISO_MOUNT_LETTER}:setup.exe
        winwait, Activision(R) - InstallShield, Select the language for the installation from the choices below.
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            controlclick, Button1, Activision(R) - InstallShield, Select the language for the installation from the choices below.
            sleep 1000
            winwait, Singularity(TM), Keycode Check
            sleep 1000
            Send $W_KEY
            sleep 1000
            Send {Enter}
            ; Well this is annoying...
            Winwait, Keycode Check, The Keycode you entered appears to be valid.
            sleep 1000
            Send {Enter}
            winwait, Singularity(TM), The InstallShield Wizard will install Singularity(TM) on your computer
            sleep 1000
            controlclick, Button1, Singularity(TM), The InstallShield Wizard will install Singularity(TM) on your computer
            winwait, Singularity(TM), Please read the following license agreement carefully
            sleep 1000
            controlclick, Button5, Singularity(TM), Please read the following license agreement carefully
            sleep 1000
            controlclick, Button2, Singularity(TM), Please read the following license agreement carefully
            winwait, Singularity(TM), Minimum System Requirements
            sleep 1000
            controlclick, Button1, Singularity(TM), Minimum System Requirements
            winwait, Singularity(TM), Select the setup type to install
            controlclick, Button4, Singularity(TM), Select the setup type to install
        }
        ; Loop until installer window has been gone for at least two seconds
        Loop
        {
            sleep 1000
            IfWinExist, Singularity
                continue
            IfWinExist, Activision
                continue
            sleep 1000
            IfWinExist, Singularity
                continue
            IfWinExist, Activision
                continue
            break
        }
        "

    if w_workaround_wine_bug 6971
    then
        w_try_winetricks mwo=force
    fi

    if w_workaround_wine_bug 22548
    then
        echo "Disabling \'depth of field\'"
        cat > "$W_TMP"/dof.reg <<_EOF_
REGEDIT4

[HKEY_CURRENT_USER\Software\Activision\Singularity]
"DepthOfField"=dword:00000000

_EOF_
        w_try_regedit "$W_TMP_WIN"\\dof.reg
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Activision\\Singularity(TM)\\Binaries" "Singularity.exe"

    # Clean up crap left over in c:\ when the installer runs the vc 2008 redistributable installer
    cd "$W_DRIVE_C"
    rm -f VC_RED.* eula.*.txt globdata.ini install.exe install.ini install.res.*.dll vcredist.bmp
}

#----------------------------------------------------------------

w_metadata  torchlight \
   title="Torchlight (Boxed version)" \
   publisher="Runic Games" \
   year=2009 \
   media=dvd \
   file1=Torchlight.iso

load_torchlight() {
    w_mount "Torchlight"
    w_ahk_do "
        SetTitleMatchMode, 2
        Run, ${W_ISO_MOUNT_LETTER}:Torchlight.exe
        WinWait, Torchlight Setup, This wizard will guide
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            ControlClick, Button2, Torchlight Setup, This wizard will guide
            WinWait, Torchlight Setup, Please review the license terms
            sleep 1000
            ControlClick, Button2, Torchlight Setup, Please review the license terms
            WinWait, Torchlight Setup, Choose Install Location
            sleep 1000
            ControlClick, Button2, Torchlight Setup, Choose Install Location
            WinWait, Torchlight Setup, Installation Complete
            sleep 1000
            ControlClick, Button2, Torchlight Setup, Installation Complete
            WinWait, Torchlight Setup, Completing the Torchlight Setup Wizard
            sleep 1000
            ControlClick, Button4, Torchlight Setup, Completing the Torchlight Setup Wizard
            ControlClick, Button2, Torchlight Setup, Completing the Torchlight Setup Wizard
        }
        WinWaitClose, Torchlight Setup
    "

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Runic Games\\Torchlight" Torchlight.exe
}

#----------------------------------------------------------------

w_metadata  twfc \
  title="Transformers: War for Cybertron" \
  publisher=Activision \
  year=2010 \
  media=dvd \
  file1=TWFC_DVD.iso

load_twfc()
{
    w_read_key
    w_mount TWFC_DVD

    w_ahk_do "
        run ${W_ISO_MOUNT_LETTER}:setup.exe
        SetTitleMatchMode, 2
        winwait, Activision, Select the language for the installation
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            controlclick, Button1, Activision, Select the language for the installation
            winwait, Transformers, Press NEXT to verify your key
            sleep 1000
            send $W_KEY
            send {Enter}
            winwait, Keycode Check, The Keycode you entered appears to be valid
            sleep 1000
            send {Enter}
            winwait, Transformers, The InstallShield Wizard will install Transformers
            sleep 1000
            controlclick, Button1, Transformers, The InstallShield Wizard will install Transformers
            winwait, Transformers, License Agreement
            sleep 1000
            controlclick, Button5, Transformers, License Agreement
            sleep 1000
            controlclick, Button2, Transformers, License Agreement
            winwait, Transformers, Minimum System Requirements
            sleep 1000
            controlclick, Button1, Transformers, Minimum System Requirements
            winwait, Transformers, Select the setup type to install
            sleep 1000
            controlclick, Button4, Transformers, Select the setup type to install
        }
        ; Installer exits silently. Prevent an early umount
        Loop
        {
            sleep 1000
            IfWinExist, Transformers
                continue
            IfWinExist, Activision
                continue
            sleep 1000
            IfWinExist, Transformers
                continue
            IfWinExist, Activision
                continue
            break
        }
    "

    if w_workaround_wine_bug 6971
    then
        w_try_winetricks mwo=force
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Activision\\Transformers - War for Cybertron\\Binaries" "TWFC.exe"

    # Clean up crap left over in c:\ when the installer runs the vc 2008 redistributable installer
    cd "$W_DRIVE_C"
    rm -f VC_RED.* eula.*.txt globdata.ini install.exe install.ini install.res.*.dll vcredist.bmp
}

#----------------------------------------------------------------

w_metadata  wog \
   title="World of Goo Demo" \
   publisher="2D Boy" \
   year="2008" \
   media="download" \
   file1="WorldOfGooDemo.1.0.exe"

load_wog()
{
    if ! test -f "$W_CACHE/wog/WorldOfGooDemo.1.0.exe"
    then
        # Get temporary download location
        w_download "http://www.worldofgoo.com/dl2.php?lk=demo&filename=WorldOfGooDemo.1.0.exe"
        URL=`cat "$W_CACHE/wog/dl2.php?lk=demo&filename=WorldOfGooDemo.1.0.exe" |
           grep WorldOfGooDemo.1.0.exe | sed 's,.*http,http,;s,".*,,'`
        rm "$W_CACHE/wog/dl2.php?lk=demo&filename=WorldOfGooDemo.1.0.exe"

        w_download "$URL" e61d8253b9fe0663cb3c69018bb3d2ec6152d488
    fi

    cd "$W_CACHE/$W_PACKAGE"
    w_ahk_do "
        run WorldOfGooDemo.1.0.exe
        winwait, World of Goo Setup, License Agreement
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            WinActivate
            send {Enter}
            winwait, World of Goo Setup, Choose Components
            send {Enter}
            winwait, World of Goo Setup, Choose Install Location
            send {Enter}
            winwait, World of Goo Setup, Thank you
            ControlClick, Make me dirty right now, World of Goo Setup, Thank you
            send {Enter}
        }
        winwaitclose, World of Goo Setup
        "
    w_declare_exe "$W_PROGRAMS_X86_WIN\\WorldOfGooDemo" WorldOfGoo.exe
}

#----------------------------------------------------------------

#---- External Verbs ----
# This is experimental, just for testing; eventually we'll load from a particular directory

for verb in *.verb
do
    if grep -sqe '^w_metadata ' $verb && grep -sqe '^load_[a-z0-9_]\(\)' $verb
    then
        ( . ./$verb )
    fi
done

#----------------------------------------------------------------

#---- Main Program ----

if ! test "$WISOTOOL_LIB"
then
    wisotool_detect_sudo
    # If no non-option arguments given, read them from GUI
    case "$1" in
    "")
        wisotool_detect_gui
        set `wisotool_showmenu`
        ;;
    esac

    rm -rf "$W_TMP"

    for W_PACKAGE in $*
    do
        mkdir -p "$W_TMP"

        case $LANG in
        de*) fail_msg="Installieren von Pakete $W_PACKAGE gescheitert" ;;
        *)   fail_msg="Failed to install package $W_PACKAGE" ;;
        esac

        case $W_PACKAGE in

        # Late options
        -*)
            if ! wisotool_handle_option $W_PACKAGE
            then
                wisotool_usage 
                exit 1
            fi
            ;;

        # External verbs
        *.verb)
            case $1 in
            */*) . $1 ;;
            *) . ./$1 ;;
            esac
            W_PACKAGE="`echo $1 | sed 's,.*/,,;s,.verb,,'`"
            if ! ( load_$W_PACKAGE )
            then
                w_die "$fail_msg"
            fi
            ;;

        # Internal verbs
        list-cached) wisotool_list_cached ;;
        list-download) wisotool_list_download ;;

        *)
            if wisotool_metadata_exists $W_PACKAGE
            then
                if ! ( load_$W_PACKAGE )
                then
                    w_die "$fail_msg"
                fi
            else
                echo Unknown arg $W_PACKAGE
                wisotool_usage
                exit 1
            fi
            ;;
        esac

        # User-specific postinstall hook.
        # Source it so the script can call w_download() if needed.
        postfile="$WISOTOOL_POST/$W_PACKAGE/$W_PACKAGE-postinstall.sh"
        if test -f "$postfile"
        then
            chmod +x "$postfile"
            ( . "$postfile" )
        fi

        rm -rf "$W_TMP"

    done

    wisotool_cleanup
fi
