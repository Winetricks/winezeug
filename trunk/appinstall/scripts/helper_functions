;
; AutoHotKey helper functions
;
; Copyright (C) 2009 Austin English
;
; This library is free software; you can redistribute it and/or
; modify it under the terms of the GNU Lesser General Public
; License as published by the Free Software Foundation; either
; version 2.1 of the License, or (at your option) any later version.
;
; This library is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
; Lesser General Public License for more details.
;
; You should have received a copy of the GNU Lesser General Public
; License along with this library; if not, write to the Free Software
; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
;

; Work around lack of some builtin variables:
; FIXME: Evenually need to get all the %164XX% values replaced. Using B_* to differentiate from AHK's builtin variables (A_*).
; http://msdn.microsoft.com/en-us/library/ms933062(WinEmbedded.5).aspx

; %16430%
RegRead, B_CommonDocs, HKEY_LOCAL_MACHINE, SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders, Common Documents

; Even though AutoHotKey comes with a ton of builtin functions, many are omitted
; due to space/speed concerns. Others aren't popular enough.

; Check to see if a directory exists. Useful for making sure installers create empty directories.
CHECK_DIR(directory)
{
global 
IfNotExist, %directory%
    {
        FileAppend, %directory% doesn't exist. Test failed.`n, %OUTPUT%
    }
Else
    {
    FileGetAttrib, Attributes, %directory%
    IfInString, Attributes, D
        {
            FileAppend, %directory% exists and is a directory. Test passed.`n, %OUTPUT%
        }
    Else
        {
            FileAppend, %directory% exists`, but isn't a directory. Test failed.`n, %OUTPUT%
        }
    }
}

; Check to see that a file exists. On success, print nothing. On failure, 'test failed' (non fatal).
; Used in place of SHA1 for things like .log or that otherwise change, but we want to make sure where installed.
CHECK_FILE(filename)
{
    global 
    IfNotExist, %filename%
    {
        FileAppend, File %filename% does not exist. Test failed.`n, %OUTPUT%
    }
}

; Removes the temporary directory and all files, recursively
CLEANUP()
{
    global 
    FileRemoveDir, %APPINSTALL_TEMP%, 1
}

; Similar to FORCE_CLOSE below, without the forced killing. Just sends the close message.
CLOSE(windowname)
{
global 
PostMessage, 0x112, 0xF060,,, %windowname%
}

; This function simplifies file retrieval. It tests for the files' existence (skipping
; the download), downloads it, sha1sum's it, and compares it against the known good
; sha1sum. To use, call 'DOWNLOAD("url", "filename", "sha1sum")' where url is the http url
; of the download (currently doesn't support ftp, will be changed later), filename is the
; filname you want to save as, and sha1sum is the 40 character sha1sum. Double-quotes must
; be used around all strings.
DOWNLOAD(url, filename, sha1sum)
{
    global 
    IfNotExist, %filename%
    {
        UrlDownloadToFile, %url%, %filename%
    }
    FileAppend, %filename% already present. Not downloading.`n, %OUTPUT%

    If GetLastError
    {
        FileAppend, Downloading %filename% failed. Error 2. Test failed.`n, %OUTPUT%
        exit 2
    }
    
    TEMPFILE=%APPINSTALL_TEMP%\sha1sum.txt
    FileDelete, %TEMPFILE%
    RunWait, %comspec% /c %APPINSTALL%\sha1sum.exe %filename% >> %TEMPFILE%
    FileReadLine, checksum, %TEMPFILE%, 1
    FileDelete, %TEMPFILE%

    sha1sumgood = %sha1sum%  %filename%
    
    If (checksum != sha1sumgood)
    {
    FileAppend, %filename% checksum failed. Got %checksum%`, expected %sha1sum%. Error 3. Test failed.`n, %OUTPUT%
    exit 3
    }
}

; Check for 'If GetLastError', and if it exists, print a line in the output file,
; remove the temporary directory, then exit with the assigned error code. Otherwise,
; print a message in the log that the test passed.
ERROR_TEST(fail_message, pass_message, errorcode=1)
{
    global 
    If GetLastError
    {
        FileAppend, %FAIL_MESSAGE% Error %ERRORCODE%. Test failed.`n, %OUTPUT%
        FileRemoveDir, %APPINSTALL_TEMP%, 1
        exit %errorcode%
    }
    Else
    {
        FileAppend, %PASS_MESSAGE% Test passed.`n, %OUTPUT%
    }
}

; Force a window to close. AutoHotKey comes with the 'WinClose' function, which sends WM_CLOSE and asks
; the program to close nicely. 'WinKill' is an extended version, which is supposed to send WM_CLOSE, and if it fails,
; terminates the program's process. I found it to be inconsistent, on both Windows and Wine. As a backup, the AHK FAQ
; offers a workaround, which I greatly prefer. For reference, 0x112 = WM_SYSCOMMAND, 0xF060 = SC_CLOSE. This is equivalent
; to clicking on the system menu and choosing 'Close', or roughly equivalent to 'ALT+F4'. It is much more consistent.

FORCE_CLOSE(windowname)
{
global 
PostMessage, 0x112, 0xF060,,, %windowname%
; Give the app 5 seconds to close on its own, to prevent race conditions. Thanks to Focht for pointing it out.
    Loop, 5
    {
        IfWinExist, %windowname%
        {
            Sleep, 1000
        }
        Else
        {
            FileAppend, %windowname% exited on its own.`n, %OUTPUT%
            break ; The app exited on its own, so break loop.
        }
    }
    IfWinExist, %windowname%
    {
        FileAppend, %windowname% didn't exit on its own. Terminating with extreme prejudice.`n, %OUTPUT%
        WinKill, %windowname%
    }
}

; Sha1sum a file, and compare it to a known good sha1sum. Similar to the download
; function above, but should be used for files not specifically downloaded, e.g.,
; to sha1sum a file from a zip directory after extraction.
; Feed it a filename and sha1sum, it will compare them, print good or bad, and if bad,
; delete the file. Be sure to quote strings! 
SHA1(sha1sum, filename)
{
    global 
    TEMPFILE=%APPINSTALL_TEMP%\sha1sum.txt
    FileDelete, %TEMPFILE%
    RunWait, %comspec% /c %APPINSTALL%\sha1sum.exe "%filename%" >> %TEMPFILE%
    FileReadLine, checksum, %TEMPFILE%, 1
    FileDelete, %TEMPFILE%
    sha1sumgood = %sha1sum%  %filename%
    If (checksum != sha1sumgood)
    {
        FileAppend, %filename% checksum failed. Got %checksum%`, expected %sha1sumgood%. Error 3. Test failed.`n, %OUTPUT%
        FileDelete, %filename%
        exit 3
    }
}

; Similar to CHECK_FILE() above, but uses TODO_FIXED/TODO_FAILED. Also, requires a bug number.
; You did file a bug for the incomplete installation, didn't you ;-)?
TODO_CHECK_FILE(filename, bug)
{
    global 
    IfExist, %filename%
    {
        FileAppend, File %filename% exists. Bug %bug% TODO_FIXED.`n, %OUTPUT%
    }
    Else
    {
        FileAppend, File %filename% does not exist. Bug %bug% TODO_FAILED.`n, %OUTPUT%
    }
}

; Similar to the SHA1 function above, but for todo's. Takes the 'bad'/expected sha1um,
; as well as the good sha1sum, and the file to test. Sha1sum's the file, and if 
; it matches the 'bad'/expected sha1sum, consider it a TODO_FAIL. If it matches
; the good sha1sum, consider it a TODO_FIXED. If it matches neither, consider it
; a test failure and exit.
TODO_SHA1(badsha1, todosha1, filename)
{
    global 
    TEMPFILE=%APPINSTALL_TEMP%\sha1sum.txt
    FileDelete, %TEMPFILE%
    RunWait, %comspec% /c %APPINSTALL%\sha1sum.exe "%filename%" >> %TEMPFILE%
    FileReadLine, checksum, %TEMPFILE%, 1
    FileDelete, %TEMPFILE%
    badsha1sum = %badsha1%  %filename%
    todosha1sum = %todosha1%  %filename%
    If (checksum = badsha1sum)
    {
        FileAppend, %filename% checksum failed. This was expected. TODO_FAILED.`n, %OUTPUT%
    }
    else if (checksum = todosha1sum)
    {
        FileAppend, %filename% checksum passed. This was not expected. TODO_FIXED.`n, %OUTPUT%
    }
    Else
    {
        FileAppend, %filename% checksum failed. Got %checksum%`, expected %badsha1um% or %todosha1sum%. Error 3. Test failed.`n, %OUTPUT%
        FileDelete, %filename%
        exit 3
    }
}

; Similar to WINDOW_WAIT below, except, instead of erroring out if the window doesn't appear, consider it a test failure.
; Should be used for windows that appear on Windows, but not on Wine, e.g., the Import Wizard for Mozilla Firefox
TODO_WINDOW_WAIT(windowname, bug, windowtext="", wintimeout=10)
{
    global 
    WinWait, %windowname%, %windowtext%, %wintimeout%
    if ErrorLevel
    {
        FileAppend, %windowname% didn't appear. Bug %bug% TODO_FAILED.`n, %OUTPUT%
    }
    Else
    {
    FileAppend, %windowname% appeared. Bug %bug% TODO_FIXED.`n, %OUTPUT%
    IfWinNotActive, %windowname%, %windowtext%
        {
        WinActivate, %windowname%, %windowtext%
        }
    }
}

; Crash handler for programs that crash on wine (but not windows). Give it the program name (as a string!),
; and the bug number (no quotes needed), and optionally a timeout period to wait (10 second default). 
; The function waits (until the timeout) for the gui debugger to pop up. If it does, it clicks 'Ok' and exits
; the test (since the program fatally crashed). If not, it outputs a message to the log files letting you know
; that the bug is likely fixed.
WAIT_CRASH_FATAL(program, bug, timeout=10)
{
global 

WinWait, Program Error, The program %program% has encountered a serious problem and needs to close, %timeout%
    if ErrorLevel
    {
        FileAppend, %program% didn't crash. Bug %bug% TODO_FIXED.`n, %OUTPUT%
    }
    else
    {
    IfWinNotActive, Program Error, The program %program% has encountered a serious problem and needs to close
        {
        WinActivate, Program Error, The program %program% has encountered a serious problem and needs to close
        }
    FileAppend, %program% crashed. Bug %bug% TODO_FAILED.`n, %OUTPUT%
    ControlClick, Button1, Program Error
    exit 0
    }
}

; Test to see that a window doesn't exist. If so, issue a test failed. Otherwise, report success.
WIN_EXIST_TEST(windowname, windowtext="")
{
    global 
    IfWinExist, %windowname%, %windowtext%
    {
        FileAppend, %windowname% didn't exit for some reason. Test failed.`n, %OUTPUT%
    }
    IfWinNotExist, %windowname%, %windowtext%
    {
        FileAppend, %windowname% exited successfully. Test passed.`n, %OUTPUT%
    }
}

; Some applications don't take focus when started, or have a delay. Work around this. 
; Windowname is required, but you can optionally supply a string of text in the window,
; or override the time to wait for the window to show before reporting failure (default, 10s).
WINDOW_WAIT(windowname, windowtext="", wintimeout=10)
{
    global 
    WinWait, %windowname%, %windowtext%, %wintimeout%
    if ErrorLevel
    {
        FileAppend, Launching %windowname% failed. Test failed.`n, %OUTPUT%
        exit 1
    }
    IfWinNotActive, %windowname%, %windowtext%
        {
        WinActivate, %windowname%, %windowtext%
        }
}
