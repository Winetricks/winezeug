diff --git a/configure.ac b/configure.ac
index a6be56f..04c5e88 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2955,8 +2955,11 @@ WINE_CONFIG_DLL(uxtheme,,[implib])
 WINE_CONFIG_TEST(dlls/uxtheme/tests)
 WINE_CONFIG_DLL(vbscript)
 WINE_CONFIG_TEST(dlls/vbscript/tests)
-WINE_CONFIG_DLL(vcomp)
-WINE_CONFIG_DLL(vcomp100)
+WINE_CONFIG_DLL(vcomp,,[implib])
+WINE_CONFIG_TEST(dlls/vcomp/tests)
+WINE_CONFIG_DLL(vcomp90)
+WINE_CONFIG_DLL(vcomp100,,[implib])
+WINE_CONFIG_TEST(dlls/vcomp100/tests)
 WINE_CONFIG_DLL(vdhcp.vxd,enable_win16)
 WINE_CONFIG_DLL(vdmdbg,,[implib])
 WINE_CONFIG_DLL(ver.dll16,enable_win16)
diff --git a/dlls/vcomp/Makefile.in b/dlls/vcomp/Makefile.in
index d256526..5dfd503 100644
--- a/dlls/vcomp/Makefile.in
+++ b/dlls/vcomp/Makefile.in
@@ -1,6 +1,7 @@
 MODULE = vcomp.dll
 
 C_SRCS = \
-	main.c
+	main.c \
+	atomic.c
 
 @MAKE_DLL_RULES@
diff --git a/dlls/vcomp/atomic.c b/dlls/vcomp/atomic.c
new file mode 100644
index 0000000..d2f259e
--- /dev/null
+++ b/dlls/vcomp/atomic.c
@@ -0,0 +1,67 @@
+/*
+ *
+ * vcomp atomic ops implementation
+ *
+ * Copyright 2012 Dan Kegel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winternl.h"
+#include "winbase.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(vcomp);
+
+void CDECL vcomp_atomic_add_i1(char   *p, char   val) { *p += val; }
+void CDECL vcomp_atomic_add_i2(short  *p, short  val) { *p += val; }
+void CDECL vcomp_atomic_add_i4(int    *p, int    val) { *p += val; }
+void CDECL vcomp_atomic_add_i8(INT64  *p, INT64  val) { *p += val; }
+void CDECL vcomp_atomic_add_r4(float  *p, float  val) { *p += val; }
+void CDECL vcomp_atomic_add_r8(double *p, double val) { *p += val; }
+void CDECL vcomp_atomic_and_i1(char   *p, char   val) { *p &= val; }
+void CDECL vcomp_atomic_and_i2(short  *p, short  val) { *p &= val; }
+void CDECL vcomp_atomic_and_i4(int    *p, int    val) { *p &= val; }
+void CDECL vcomp_atomic_and_i8(INT64  *p, INT64  val) { *p &= val; }
+void CDECL vcomp_atomic_div_i1(char   *p, char   val) { *p /= val; }
+void CDECL vcomp_atomic_div_i2(short  *p, short  val) { *p /= val; }
+void CDECL vcomp_atomic_div_i4(int    *p, int    val) { *p /= val; }
+void CDECL vcomp_atomic_div_i8(INT64  *p, INT64  val) { *p /= val; }
+void CDECL vcomp_atomic_div_r4(float  *p, float  val) { *p /= val; }
+void CDECL vcomp_atomic_div_r8(double *p, double val) { *p /= val; }
+void CDECL vcomp_atomic_mul_i1(char   *p, char   val) { *p *= val; }
+void CDECL vcomp_atomic_mul_i2(short  *p, short  val) { *p *= val; }
+void CDECL vcomp_atomic_mul_i4(int    *p, int    val) { *p *= val; }
+void CDECL vcomp_atomic_mul_i8(INT64  *p, INT64  val) { *p *= val; }
+void CDECL vcomp_atomic_mul_r4(float  *p, float  val) { *p *= val; }
+void CDECL vcomp_atomic_mul_r8(double *p, double val) { *p += val; }
+void CDECL vcomp_atomic_or_i1 (char   *p, char   val) { *p |= val; }
+void CDECL vcomp_atomic_or_i2 (short  *p, short  val) { *p |= val; }
+void CDECL vcomp_atomic_or_i4 (int    *p, int    val) { *p |= val; }
+void CDECL vcomp_atomic_or_i8 (INT64  *p, INT64  val) { *p |= val; }
+void CDECL vcomp_atomic_sub_i1(char   *p, char   val) { *p -= val; }
+void CDECL vcomp_atomic_sub_i2(short  *p, short  val) { *p -= val; }
+void CDECL vcomp_atomic_sub_i4(int    *p, int    val) { *p -= val; }
+void CDECL vcomp_atomic_sub_i8(INT64  *p, INT64  val) { *p -= val; }
+void CDECL vcomp_atomic_sub_r4(float  *p, float  val) { *p -= val; }
+void CDECL vcomp_atomic_sub_r8(double *p, double val) { *p -= val; }
+void CDECL vcomp_atomic_xor_i1(char   *p, char   val) { *p ^= val; }
+void CDECL vcomp_atomic_xor_i2(short  *p, short  val) { *p ^= val; }
+void CDECL vcomp_atomic_xor_i4(int    *p, int    val) { *p ^= val; }
+void CDECL vcomp_atomic_xor_i8(INT64  *p, INT64  val) { *p ^= val; }
diff --git a/dlls/vcomp/main.c b/dlls/vcomp/main.c
index 0a3c4f5..d800aea 100644
--- a/dlls/vcomp/main.c
+++ b/dlls/vcomp/main.c
@@ -21,14 +21,346 @@
 
 #include "config.h"
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
 #include <stdarg.h>
 
 #include "windef.h"
+#include "winternl.h"
 #include "winbase.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(vcomp);
 
+/* The OpenMP 2.0 C and C++ Application Program Interface
+ * standard included stubs in Appendix B.
+ * "Copyright 2002 OpenMP Architecture Review Board
+ * Permission to copy without fee all or part of this material is granted,
+ * provided the OpenMP Architecture Review Board copyright notice and the
+ * title of this document appear."
+ */
+
+/* FIXME: put in omp.h */
+enum {UNLOCKED = -1, INIT, LOCKED};
+/* FIXME: match real definition */
+typedef int omp_lock_t;
+
+void CDECL VCOMP_omp_set_num_threads(int num_threads)
+{
+    TRACE("(%d): stub\n", num_threads);
+}
+
+int CDECL VCOMP_omp_get_max_threads(void)
+{
+    TRACE("stub\n");
+    return 1;
+}
+
+int CDECL VCOMP_omp_get_num_threads(void)
+{
+    TRACE("stub\n");
+    return 1;
+}
+
+int CDECL VCOMP_omp_get_thread_num(void)
+{
+    TRACE("stub\n");
+    return 0;
+}
+
+int CDECL VCOMP_omp_get_num_procs(void)
+{
+    TRACE("stub\n");
+    return 1;
+}
+
+void CDECL VCOMP_omp_set_dynamic(int val)
+{
+    TRACE("(%d): stub\n", val);
+}
+
+int CDECL VCOMP_omp_get_dynamic(void)
+{
+    TRACE("stub\n");
+    return 0;
+}
+
+int CDECL VCOMP_omp_in_parallel(void)
+{
+    TRACE("stub\n");
+    return 0;
+}
+
+void CDECL VCOMP_omp_set_nested(int nested)
+{
+    TRACE("(%d): stub\n", nested);
+}
+
+int CDECL VCOMP_omp_get_nested(void)
+{
+    TRACE("stub\n");
+    return 0;
+}
+
+void VCOMP_omp_init_lock(omp_lock_t *lock)
+{
+    TRACE("(%p): stub\n", lock);
+    *lock = UNLOCKED;
+}
+
+void VCOMP_omp_destroy_lock(omp_lock_t *lock)
+{
+    TRACE("(%p): stub\n", lock);
+    *lock = INIT;
+}
+
+void VCOMP_omp_set_lock(omp_lock_t *lock)
+{
+    TRACE("(%p): stub\n", lock);
+    if (*lock == UNLOCKED) {
+        *lock = LOCKED;
+    } else if (*lock == LOCKED) {
+        ERR("deadlock in using lock variable\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+    } else {
+        ERR("lock not initialized\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+    }
+}
+
+void CDECL VCOMP_omp_unset_lock(omp_lock_t *lock)
+{
+    TRACE("(%p): stub\n", lock);
+    if (*lock == LOCKED) {
+        *lock = UNLOCKED;
+    } else if (*lock == UNLOCKED) {
+        ERR("lock not set\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+    } else {
+        ERR("lock not initialized\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+    }
+}
+
+int CDECL VCOMP_omp_test_lock(omp_lock_t *lock)
+{
+    TRACE("(%p): stub\n", lock);
+    if (*lock == UNLOCKED) {
+        *lock = LOCKED;
+        return 1;
+    } else if (*lock == LOCKED) {
+        return 0;
+    } else {
+        ERR("lock not initialized\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+        return -1;
+    }
+}
+
+#ifndef OMP_NEST_LOCK_T
+typedef struct {  /* This really belongs in omp.h */
+    int owner;
+    int count;
+} omp_nest_lock_t;
+#endif
+
+enum {MASTER = 0};
+
+void VCOMP_omp_init_nest_lock(omp_nest_lock_t * lock)
+{
+    lock->owner = UNLOCKED;
+    lock->count = 0;
+}
+
+void VCOMP_omp_destroy_nest_lock(omp_nest_lock_t * lock)
+{
+    lock->owner = UNLOCKED;
+    lock->count = UNLOCKED;
+}
+
+void VCOMP_omp_set_nest_lock(omp_nest_lock_t * lock)
+{
+    if (lock->owner == MASTER && lock->count >= 1) {
+	lock->count++;
+    } else if (lock->owner == UNLOCKED && lock->count == 0) {
+	lock->owner = MASTER;
+	lock->count = 1;
+    } else {
+        ERR("lock corrupted or not initialized\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+    }
+}
+
+void VCOMP_omp_unset_nest_lock(omp_nest_lock_t * lock)
+{
+    if (lock->owner == MASTER && lock->count >= 1) {
+	lock->count--;
+	if (lock->count == 0) {
+	    lock->owner = UNLOCKED;
+	}
+    } else if (lock->owner == UNLOCKED && lock->count == 0) {
+        ERR("lock not set\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+    } else {
+        ERR("lock corrupted or not initialized\n");
+        RaiseException( STATUS_INVALID_CRUNTIME_PARAMETER, EXCEPTION_NONCONTINUABLE, 0, NULL );
+    }
+}
+
+int VCOMP_omp_test_nest_lock(omp_nest_lock_t * lock)
+{
+    VCOMP_omp_set_nest_lock(lock);
+    return lock->count;
+}
+
+void CDECL VCOMP__vcomp_enter_critsect(void *section)
+{
+    TRACE("(%p): stub\n", section);
+}
+
+void CDECL VCOMP__vcomp_leave_critsect(void *section)
+{
+    TRACE("(%p): stub\n", section);
+}
+
+void CDECL VCOMP__vcomp_barrier(void)
+{
+    TRACE("stub\n");
+}
+
+#ifdef __i386__
+extern void WINAPIV VCOMP__vcomp_fork(DWORD parallel, int ncount, void (__cdecl *helper)(__ms_va_list), ...);
+/* Call helper with the ncount args after ncount */
+__ASM_GLOBAL_FUNC( VCOMP__vcomp_fork,
+                   "push %ebp\n\t"
+                   "movl %esp,%ebp\n\t"
+                   "leal 20(%ebp),%edx\n\t" /* first varadic arg */
+                   "movl 12(%ebp),%ecx\n\t" /* ncount */
+                   "test %ecx,%ecx\n\t"
+                   "jz loopend\n\t"
+                   "leal (%edx,%ecx,4),%edx\n\t" /* skip to after last arg */
+                   "looptop:\n\t"
+                   "sub $4,%edx\n\t"
+                   "pushl (%edx)\n\t"
+                   "dec %ecx\n\t"
+                   "jnz looptop\n\t"
+                   "loopend:\n\t"
+                   "call 16(%ebp)\n\t"      /* call helper */
+                   "movl %ebp,%esp\n\t"     /* pop varadic args */
+                   "pop %ebp\n\t"
+                   "ret\n\t"
+                 )
+#elif defined(__x86_64__)
+void WINAPIV VCOMP__vcomp_fork(DWORD parallel, int ncount, void (__cdecl *helper)(__ms_va_list), ...)
+{
+    FIXME("stub\n");
+}
+#endif
+
+void CDECL VCOMP__vcomp_for_static_simple_init(int first, int last, int mystep, int step, int *pfirst, int *plast)
+{
+    TRACE("(%d, %d, %d, %d, %p, %p): stub\n", first, last, mystep, step, pfirst, plast);
+    *pfirst = first;
+    *plast = last;
+}
+
+void CDECL VCOMP__vcomp_for_static_end(void)
+{
+    TRACE("stub\n");
+}
+
+/* FIXME: where should these be stored? */
+static int vcomp_loop_counter;
+static int vcomp_loop_step;
+static int vcomp_loop_iterations_remaining;
+static int vcomp_loop_chunksize;
+
+void CDECL VCOMP__vcomp_for_dynamic_init(int flags, int first, int last, int mystep, int chunksize)
+{
+    TRACE("(%d, %d, %d, %d, %d): stub\n", flags, first, last, mystep, chunksize);
+    vcomp_loop_counter = first;
+    vcomp_loop_chunksize = chunksize;
+    if (flags & 0x40) {
+        vcomp_loop_step = mystep;
+    } else {
+        vcomp_loop_step = -mystep;
+    }
+    vcomp_loop_iterations_remaining = 1 + (last - first) / vcomp_loop_step;
+}
+
+int CDECL VCOMP__vcomp_for_dynamic_next(int *pcounter, int *pchunklimit)
+{
+    int n;
+    TRACE("(%p, %p): stub. counter %d, remaining %d\n", pcounter, pchunklimit, vcomp_loop_counter, vcomp_loop_iterations_remaining);
+    n = vcomp_loop_chunksize;
+    if (n > vcomp_loop_iterations_remaining)
+        n = vcomp_loop_iterations_remaining;
+    *pcounter = vcomp_loop_counter;
+    vcomp_loop_counter += vcomp_loop_step * n;
+    *pchunklimit = vcomp_loop_counter - 1;
+    vcomp_loop_iterations_remaining -= n;
+
+    TRACE("at exit, counter %d, remaining %d, n %d\n", vcomp_loop_counter, vcomp_loop_iterations_remaining, n);
+    return (n > 0);
+}
+
+double CDECL VCOMP_omp_get_wtick(void)
+{
+    TRACE("stub\n");
+    /* Wild guess */
+    return 0.001;
+}
+
+double CDECL VCOMP_omp_get_wtime(void)
+{
+    TRACE("stub\n");
+    return GetTickCount() / (double) 1000.0;
+}
+
+/* FIXME: where should this be stored? */
+static int vcomp_section_counter;
+
+void CDECL VCOMP__vcomp_sections_init(int n)
+{
+    TRACE("(%d): stub\n", n);
+    vcomp_section_counter = 0;
+}
+
+int CDECL VCOMP__vcomp_sections_next(void)
+{
+    TRACE("stub; returning %d\n", vcomp_section_counter);
+    return vcomp_section_counter++;
+}
+
+void CDECL VCOMP__vcomp_set_num_threads(int num_threads)
+{
+    TRACE("(%d): stub\n", num_threads);
+    VCOMP_omp_set_num_threads(num_threads);
+}
+
+int CDECL VCOMP__vcomp_master_begin(void)
+{
+    TRACE("stub\n");
+    return TRUE;
+}
+
+void CDECL VCOMP__vcomp_master_end(void)
+{
+    TRACE("stub\n");
+}
+
+int CDECL VCOMP__vcomp_single_begin(int flags)
+{
+    TRACE("(%x): stub\n", flags);
+    return TRUE;
+}
+
+void CDECL VCOMP__vcomp_single_end(void)
+{
+    TRACE("stub\n");
+}
+
 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
     TRACE("(0x%p, %d, %p)\n", hinstDLL, fdwReason, lpvReserved);
diff --git a/dlls/vcomp/tests/Makefile.in b/dlls/vcomp/tests/Makefile.in
new file mode 100644
index 0000000..f846a77
--- /dev/null
+++ b/dlls/vcomp/tests/Makefile.in
@@ -0,0 +1,11 @@
+TESTDLL = vcomp.dll
+IMPORTS = vcomp
+
+C_SRCS = \
+	main.c \
+	atomic.c
+
+RC_SRCS = \
+	vcomp.rc
+
+@MAKE_TEST_RULES@
diff --git a/dlls/vcomp/tests/atomic.c b/dlls/vcomp/tests/atomic.c
new file mode 100644
index 0000000..ca433a1
--- /dev/null
+++ b/dlls/vcomp/tests/atomic.c
@@ -0,0 +1,83 @@
+/*
+ * Unit test suite for vcomp functions.
+ *
+ * Copyright 2012 Dan Kegel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "wine/test.h"
+#include <stdio.h>
+
+static void test_atomic_add(void)
+{
+#if 1
+    CHAR i1;
+    INT16 i2;
+    INT32 i4;
+    INT64 i8;
+    float r4;
+    double r8;
+
+    /* FIXME: should these be in some private header? */
+    void CDECL _vcomp_atomic_add_i1(char  *p, short  val);
+    void CDECL _vcomp_atomic_add_i2(short  *p, short  val);
+    void CDECL _vcomp_atomic_add_i4(int    *p, int    val);
+    void CDECL _vcomp_atomic_add_i8(INT64  *p, INT64  val);
+    void CDECL _vcomp_atomic_add_r4(float  *p, float  val);
+    void CDECL _vcomp_atomic_add_r8(double *p, double val);
+
+    i1 = 0;
+    _vcomp_atomic_add_i1(&i1, 1);
+    ok(i1 == 1, "1 + 1 == 1\n");
+    i1 = 0x7f;
+    _vcomp_atomic_add_i1(&i1, 1);
+    ok((0xff & i1) == 0x80, "0x7f + 1 == 0x80 was 0x%x\n", (0xff & i1));
+
+    i2 = 0;
+    _vcomp_atomic_add_i2(&i2, 1);
+    ok(i2 == 1, "1 + 1 == 1\n");
+    i2 = 0x7fff;
+    _vcomp_atomic_add_i2(&i2, 1);
+    ok((0xffff & i2) == 0x8000, "0x7fff + 1 == 0x8000, was 0x%x\n", (0xffff & i2));
+
+    i4 = 0;
+    _vcomp_atomic_add_i4(&i4, 1);
+    ok(i4 == 1, "1 + 1 == 1\n");
+    i4 = 0x7fffffffU;
+    _vcomp_atomic_add_i4(&i4, 1);
+    ok((0xffffffff & i4) == 0x80000000, "0x7fffffff + 1 == 0x8000000, was 0x%x\n", (0xffffffff & i4));
+
+    i8 = 0;
+    _vcomp_atomic_add_i8(&i8, 1);
+    ok(i8 == 1, "1 + 1 == 1\n");
+#if _WIN64
+    i8 = 0x7fffffffffffffffL;
+    _vcomp_atomic_add_i8(&i8, 1);
+    ok(i8 == 0x8000000000000000L, "0x7fffffffffffffffL + 1 == 0x8000000000000000L, was 0x%lx\n", i8);
+#else
+    i8 = 0x7fffffffffffffffLL;
+    _vcomp_atomic_add_i8(&i8, 1);
+    ok(i8 == 0x8000000000000000LL, "0x7fffffffffffffffLL + 1 == 0x8000000000000000LL, was 0x%lx\n", i8);
+#endif
+#endif
+}
+
+START_TEST(atomic)
+{
+    printf("Starting atomic test.\n");
+    test_atomic_add();
+    printf("Ending atomic test.\n");
+}
diff --git a/dlls/vcomp/tests/main.c b/dlls/vcomp/tests/main.c
new file mode 100644
index 0000000..f496410
--- /dev/null
+++ b/dlls/vcomp/tests/main.c
@@ -0,0 +1,182 @@
+/*
+ * Unit test suite for vcomp functions.
+ *
+ * Copyright 2012 Dan Kegel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "wine/test.h"
+#include <stdio.h>
+
+/* FIXME: should be in omp.h */
+void CDECL omp_set_num_threads(int);
+int CDECL omp_get_max_threads(void);
+int CDECL omp_get_num_threads(void);
+int CDECL omp_get_thread_num(void);
+int CDECL omp_get_num_procs(void);
+int CDECL omp_in_parallel(void);
+
+/* Should we have a private vcomp.h? */
+//void WINAPIV _vcomp_fork(DWORD, DWORD, void (__cdecl *)(__ms_va_list), ...);
+void WINAPIV _vcomp_fork(DWORD, DWORD, void *, ...);
+void CDECL _vcomp_for_static_simple_init(int first, int last, int mystep, int step, int *pfirst, int *plast);
+void CDECL _vcomp_for_static_end(void);
+int CDECL _vcomp_for_dynamic_next(int *pcounter, int *plimit);
+void CDECL _vcomp_for_dynamic_init(int flags, int first, int last, int mystep, int chunksize);
+void CDECL _vcomp_atomic_add_i4(int    *p, int    val);
+
+void test_omp_get_num_threads(void)
+{
+    int nt = omp_get_num_threads();
+    ok(nt == 1, "omp_get_num_threads() outside parallel was %d, but should be 1\n", nt);
+}
+
+void test_omp_get_max_threads(void)
+{
+    int mt = omp_get_max_threads();
+    ok(mt >= 1, "omp_get_max_threads() was %d, but should be at least 1\n", mt);
+}
+
+void test_omp_get_thread_num(void)
+{
+    int tnum;
+    tnum = omp_get_thread_num();
+    ok(tnum == 0, "omp_get_thread_num() outside parallel was %d, but should be 0\n", tnum);
+}
+
+void test_omp_get_num_procs(void)
+{
+    int np = omp_get_num_procs();
+    ok(np >= 1, "omp_get_num_procs() outside parallel was %d, but should be >= 1\n", np);
+}
+
+void test_omp_in_parallel(void)
+{
+    int ip = omp_in_parallel();
+    ok(ip == 0, "omp_in_parallel() outside parallel was %d, but should be 0\n", ip);
+}
+
+LONG volatile ncalls;
+
+void workerfunc1(int a, int b, int c, int d)
+{
+    ok(a == 1, "expected a == 1, got %d\n", a);
+    ok(b == 2, "expected b == 2, got %d\n", b);
+    ok(c == 3, "expected c == 3, got %d\n", c);
+    ok(d == 4, "expedted d == 4, got %d\n", d);
+    InterlockedIncrement(&ncalls);
+}
+
+void workerfunc2(LONG volatile *p)
+{
+    printf("in workerfunc2\n");
+    InterlockedIncrement(p);
+}
+
+void test_vcomp_fork(void)
+{
+    ncalls = 0;
+    _vcomp_fork(0, 4, workerfunc1, 1, 2, 3, 4);
+    printf("with parallel=0, ncalls is %d\n", ncalls);
+    ok(ncalls == 1, "expected 1 call, got %d\n", ncalls);
+
+    ncalls = 0;
+    _vcomp_fork(1, 4, workerfunc1, 1, 2, 3, 4);
+    printf("with parallel=1, ncalls is %d\n", ncalls);
+    ok(ncalls >= 1, "expected >= 1 call, got %d\n", ncalls);
+
+    ncalls = 0;
+    _vcomp_fork(0, 1, workerfunc2, &ncalls);
+    printf("with parallel=0, ncalls is %d\n", ncalls);
+    ok(ncalls == 1, "expected 1 call, got %d\n", ncalls);
+}
+
+LONG nsum;
+
+void worker_simple_for(void)
+{
+    int i, my_limit;
+
+    InterlockedIncrement(&ncalls);
+
+    /* for (i=0; i<=12; i++) */
+    _vcomp_for_static_simple_init(0, 12, 1, 1, &i, &my_limit);
+
+    printf("i is %d, my_limit is %d\n", i, my_limit);
+    while (i <= my_limit) {
+        _vcomp_atomic_add_i4(&nsum, i);
+        i++;
+    }
+
+    printf("Loop is done, nsum is %d\n", nsum);
+    _vcomp_for_static_end();
+}
+
+void test_simple_for(void)
+{
+    ncalls = 0;
+    nsum = 0;
+    _vcomp_fork(1, 0, worker_simple_for);
+    printf("with parallel=1, ncalls is %d, nsum is %d\n", ncalls, nsum);
+    ok(ncalls >= 1, "expected >= 1 call, got %d\n", ncalls);
+    ok(nsum == 6*13, "expected sum 6*13, got %d\n", nsum);
+}
+
+void worker_dynamic_for(void)
+{
+    int i, limit;
+
+    InterlockedIncrement(&ncalls);
+
+    /* pragma omp schedule(dynamic,16) */
+    /* for (i=0; i<=17; i++) */
+    _vcomp_for_dynamic_init(98, 0, 17, 1, 16);
+
+    printf("top of loop\n");
+    while (_vcomp_for_dynamic_next(&i, &limit)) {
+        for (; i<=limit; i++) {
+            printf("i is %d, limit is %d\n", i, limit);
+            _vcomp_atomic_add_i4(&nsum, i);
+        }
+    }
+
+    printf("Loop is done, nsum is %d\n", nsum);
+}
+
+void test_dynamic_for(void)
+{
+    ncalls = 0;
+    nsum = 0;
+    _vcomp_fork(1, 0, worker_dynamic_for);
+    printf("with parallel=1, ncalls is %d, nsum is %d\n", ncalls, nsum);
+    ok(ncalls >= 1, "expected >= 1 call, got %d\n", ncalls);
+    ok(nsum == 9*17, "expected sum 9*17, got %d\n", nsum);
+}
+
+START_TEST(main)
+{
+    printf("Starting test\n");
+    test_omp_get_num_threads();
+    test_omp_get_max_threads();
+    test_omp_get_thread_num();
+    test_omp_get_num_procs();
+    test_omp_in_parallel();
+    test_vcomp_fork();
+    test_simple_for();
+    test_dynamic_for();
+
+    printf("Main test over.\n");
+}
diff --git a/dlls/vcomp/tests/vcomp.manifest b/dlls/vcomp/tests/vcomp.manifest
new file mode 100644
index 0000000..e6c2bc1
--- /dev/null
+++ b/dlls/vcomp/tests/vcomp.manifest
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <assemblyIdentity
+      type="win32"
+      name="Wine.vcomp.Test"
+      version="1.0.0.0"
+      processorArchitecture="*"
+  />
+<description>Wine vcomp test suite</description>
+<dependency>
+  <dependentAssembly>
+    <assemblyIdentity
+        type="win32"
+        name="Microsoft.VC80.OpenMP"
+        version="8.0.50727.762"
+        processorArchitecture="*"
+        publicKeyToken="1fc8b3b9a1e18e3b"
+    />
+  </dependentAssembly>
+</dependency>
+</assembly>
diff --git a/dlls/vcomp/tests/vcomp.rc b/dlls/vcomp/tests/vcomp.rc
new file mode 100644
index 0000000..d22f1a5
--- /dev/null
+++ b/dlls/vcomp/tests/vcomp.rc
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2010 Detlef Riekenberg
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "winuser.h"
+
+/* @makedep: vcomp.manifest */
+1 RT_MANIFEST vcomp.manifest
diff --git a/dlls/vcomp/vcomp.spec b/dlls/vcomp/vcomp.spec
index cd5a964..3a84760 100644
--- a/dlls/vcomp/vcomp.spec
+++ b/dlls/vcomp/vcomp.spec
@@ -1,33 +1,33 @@
-@ stub _vcomp_atomic_add_i1
-@ stub _vcomp_atomic_add_i2
-@ stub _vcomp_atomic_add_i4
-@ stub _vcomp_atomic_add_i8
-@ stub _vcomp_atomic_add_r4
-@ stub _vcomp_atomic_add_r8
-@ stub _vcomp_atomic_and_i1
-@ stub _vcomp_atomic_and_i2
-@ stub _vcomp_atomic_and_i4
-@ stub _vcomp_atomic_and_i8
-@ stub _vcomp_atomic_div_i1
-@ stub _vcomp_atomic_div_i2
-@ stub _vcomp_atomic_div_i4
-@ stub _vcomp_atomic_div_i8
-@ stub _vcomp_atomic_div_r4
-@ stub _vcomp_atomic_div_r8
+@ cdecl _vcomp_atomic_add_i1(ptr long) vcomp_atomic_add_i1
+@ cdecl _vcomp_atomic_add_i2(ptr long) vcomp_atomic_add_i2
+@ cdecl _vcomp_atomic_add_i4(ptr long) vcomp_atomic_add_i4
+@ cdecl _vcomp_atomic_add_i8(ptr int64) vcomp_atomic_add_i8
+@ cdecl _vcomp_atomic_add_r4(ptr float) vcomp_atomic_add_r4
+@ cdecl _vcomp_atomic_add_r8(ptr double) vcomp_atomic_add_r8
+@ cdecl _vcomp_atomic_and_i1(ptr long) vcomp_atomic_and_i1
+@ cdecl _vcomp_atomic_and_i2(ptr long) vcomp_atomic_and_i2
+@ cdecl _vcomp_atomic_and_i4(ptr long) vcomp_atomic_and_i4
+@ cdecl _vcomp_atomic_and_i8(ptr int64) vcomp_atomic_and_i8
+@ cdecl _vcomp_atomic_div_i1(ptr long) vcomp_atomic_div_i1
+@ cdecl _vcomp_atomic_div_i2(ptr long) vcomp_atomic_div_i2
+@ cdecl _vcomp_atomic_div_i4(ptr long) vcomp_atomic_div_i4
+@ cdecl _vcomp_atomic_div_i8(ptr int64) vcomp_atomic_div_i8
+@ cdecl _vcomp_atomic_div_r4(ptr float) vcomp_atomic_div_r4
+@ cdecl _vcomp_atomic_div_r8(ptr double) vcomp_atomic_div_r8
 @ stub _vcomp_atomic_div_ui1
 @ stub _vcomp_atomic_div_ui2
 @ stub _vcomp_atomic_div_ui4
 @ stub _vcomp_atomic_div_ui8
-@ stub _vcomp_atomic_mul_i1
-@ stub _vcomp_atomic_mul_i2
-@ stub _vcomp_atomic_mul_i4
-@ stub _vcomp_atomic_mul_i8
-@ stub _vcomp_atomic_mul_r4
-@ stub _vcomp_atomic_mul_r8
-@ stub _vcomp_atomic_or_i1
-@ stub _vcomp_atomic_or_i2
-@ stub _vcomp_atomic_or_i4
-@ stub _vcomp_atomic_or_i8
+@ cdecl _vcomp_atomic_mul_i1(ptr long) vcomp_atomic_mul_i1
+@ cdecl _vcomp_atomic_mul_i2(ptr long) vcomp_atomic_mul_i2
+@ cdecl _vcomp_atomic_mul_i4(ptr long) vcomp_atomic_mul_i4
+@ cdecl _vcomp_atomic_mul_i8(ptr int64) vcomp_atomic_mul_i8
+@ cdecl _vcomp_atomic_mul_r4(ptr float) vcomp_atomic_mul_r4
+@ cdecl _vcomp_atomic_mul_r8(ptr double) vcomp_atomic_mul_r8
+@ cdecl _vcomp_atomic_or_i1(ptr long) vcomp_atomic_or_i1
+@ cdecl _vcomp_atomic_or_i2(ptr long) vcomp_atomic_or_i2
+@ cdecl _vcomp_atomic_or_i4(ptr long) vcomp_atomic_or_i4
+@ cdecl _vcomp_atomic_or_i8(ptr int64) vcomp_atomic_or_i8
 @ stub _vcomp_atomic_shl_i1
 @ stub _vcomp_atomic_shl_i2
 @ stub _vcomp_atomic_shl_i4
@@ -40,36 +40,36 @@
 @ stub _vcomp_atomic_shr_ui2
 @ stub _vcomp_atomic_shr_ui4
 @ stub _vcomp_atomic_shr_ui8
-@ stub _vcomp_atomic_sub_i1
-@ stub _vcomp_atomic_sub_i2
-@ stub _vcomp_atomic_sub_i4
-@ stub _vcomp_atomic_sub_i8
-@ stub _vcomp_atomic_sub_r4
-@ stub _vcomp_atomic_sub_r8
-@ stub _vcomp_atomic_xor_i1
-@ stub _vcomp_atomic_xor_i2
-@ stub _vcomp_atomic_xor_i4
-@ stub _vcomp_atomic_xor_i8
-@ stub _vcomp_barrier
+@ cdecl _vcomp_atomic_sub_i1(ptr long) vcomp_atomic_sub_i1
+@ cdecl _vcomp_atomic_sub_i2(ptr long) vcomp_atomic_sub_i2
+@ cdecl _vcomp_atomic_sub_i4(ptr long) vcomp_atomic_sub_i4
+@ cdecl _vcomp_atomic_sub_i8(ptr int64) vcomp_atomic_sub_i8
+@ cdecl _vcomp_atomic_sub_r4(ptr float) vcomp_atomic_sub_r4
+@ cdecl _vcomp_atomic_sub_r8(ptr double) vcomp_atomic_sub_r8
+@ cdecl _vcomp_atomic_xor_i1(ptr long) vcomp_atomic_xor_i1
+@ cdecl _vcomp_atomic_xor_i2(ptr long) vcomp_atomic_xor_i2
+@ cdecl _vcomp_atomic_xor_i4(ptr long) vcomp_atomic_xor_i4
+@ cdecl _vcomp_atomic_xor_i8(ptr int64) vcomp_atomic_xor_i8
+@ cdecl _vcomp_barrier() VCOMP__vcomp_barrier
 @ stub _vcomp_copyprivate_broadcast
 @ stub _vcomp_copyprivate_receive
-@ stub _vcomp_enter_critsect
+@ cdecl _vcomp_enter_critsect(ptr) VCOMP__vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long) VCOMP__vcomp_for_dynamic_init
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr) VCOMP__vcomp_for_dynamic_next
 @ stub _vcomp_for_dynamic_next_i8
-@ stub _vcomp_for_static_end
+@ cdecl _vcomp_for_static_end() VCOMP__vcomp_for_static_end
 @ stub _vcomp_for_static_init
 @ stub _vcomp_for_static_init_i8
-@ stub _vcomp_for_static_simple_init
+@ cdecl _vcomp_for_static_simple_init(long long long long ptr ptr) VCOMP__vcomp_for_static_simple_init
 @ stub _vcomp_for_static_simple_init_i8
-@ stub _vcomp_fork
+@ varargs _vcomp_fork(long long ptr) VCOMP__vcomp_fork
 @ stub _vcomp_get_thread_num
-@ stub _vcomp_leave_critsect
+@ cdecl _vcomp_leave_critsect(ptr) VCOMP__vcomp_leave_critsect
 @ stub _vcomp_master_barrier
-@ stub _vcomp_master_begin
-@ stub _vcomp_master_end
+@ cdecl _vcomp_master_begin() VCOMP__vcomp_master_begin
+@ cdecl _vcomp_master_end() VCOMP__vcomp_master_end
 @ stub _vcomp_ordered_begin
 @ stub _vcomp_ordered_end
 @ stub _vcomp_ordered_loop_end
@@ -83,30 +83,30 @@
 @ stub _vcomp_reduction_u2
 @ stub _vcomp_reduction_u4
 @ stub _vcomp_reduction_u8
-@ stub _vcomp_sections_init
-@ stub _vcomp_sections_next
-@ stub _vcomp_set_num_threads
-@ stub _vcomp_single_begin
-@ stub _vcomp_single_end
-@ stub omp_destroy_lock
-@ stub omp_destroy_nest_lock
-@ stub omp_get_dynamic
-@ stub omp_get_max_threads
-@ stub omp_get_nested
-@ stub omp_get_num_procs
-@ stub omp_get_num_threads
-@ stub omp_get_thread_num
-@ stub omp_get_wtick
-@ stub omp_get_wtime
-@ stub omp_in_parallel
-@ stub omp_init_lock
-@ stub omp_init_nest_lock
-@ stub omp_set_dynamic
-@ stub omp_set_lock
-@ stub omp_set_nest_lock
-@ stub omp_set_nested
-@ stub omp_set_num_threads
-@ stub omp_test_lock
-@ stub omp_test_nest_lock
-@ stub omp_unset_lock
-@ stub omp_unset_nest_lock
+@ cdecl _vcomp_sections_init(long) VCOMP__vcomp_sections_init
+@ cdecl _vcomp_sections_next() VCOMP__vcomp_sections_next
+@ cdecl _vcomp_set_num_threads(long) VCOMP__vcomp_set_num_threads
+@ cdecl _vcomp_single_begin(long) VCOMP__vcomp_single_begin
+@ cdecl _vcomp_single_end() VCOMP__vcomp_single_end
+@ cdecl omp_destroy_lock(ptr) VCOMP_omp_destroy_lock
+@ cdecl omp_destroy_nest_lock(ptr) VCOMP_omp_destroy_nest_lock
+@ cdecl omp_get_dynamic() VCOMP_omp_get_dynamic
+@ cdecl omp_get_max_threads() VCOMP_omp_get_max_threads
+@ cdecl omp_get_nested() VCOMP_omp_get_nested
+@ cdecl omp_get_num_procs() VCOMP_omp_get_num_procs
+@ cdecl omp_get_num_threads() VCOMP_omp_get_num_threads
+@ cdecl omp_get_thread_num() VCOMP_omp_get_thread_num
+@ cdecl omp_get_wtick() VCOMP_omp_get_wtick
+@ cdecl omp_get_wtime() VCOMP_omp_get_wtime
+@ cdecl omp_in_parallel() VCOMP_omp_in_parallel
+@ cdecl omp_init_lock(ptr) VCOMP_omp_init_lock
+@ cdecl omp_init_nest_lock(ptr) VCOMP_omp_init_nest_lock
+@ cdecl omp_set_dynamic(long) VCOMP_omp_set_dynamic
+@ cdecl omp_set_lock(ptr) VCOMP_omp_set_lock
+@ cdecl omp_set_nest_lock(ptr) VCOMP_omp_set_nest_lock
+@ cdecl omp_set_nested(long) VCOMP_omp_set_nested
+@ cdecl omp_set_num_threads(long) VCOMP_omp_set_num_threads
+@ cdecl omp_test_lock(ptr) VCOMP_omp_test_lock
+@ cdecl omp_test_nest_lock(ptr) VCOMP_omp_test_nest_lock
+@ cdecl omp_unset_lock(ptr) VCOMP_omp_unset_lock
+@ cdecl omp_unset_nest_lock(ptr) VCOMP_omp_unset_nest_lock
diff --git a/dlls/vcomp100/main.c b/dlls/vcomp100/main.c
index a5105d3..8c5af11 100644
--- a/dlls/vcomp100/main.c
+++ b/dlls/vcomp100/main.c
@@ -27,7 +27,7 @@
 #include "winbase.h"
 #include "wine/debug.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(vcomp100);
+WINE_DEFAULT_DEBUG_CHANNEL(vcomp);
 
 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
diff --git a/dlls/vcomp100/tests/Makefile.in b/dlls/vcomp100/tests/Makefile.in
new file mode 100644
index 0000000..8cec8d1
--- /dev/null
+++ b/dlls/vcomp100/tests/Makefile.in
@@ -0,0 +1,8 @@
+TESTDLL = vcomp100.dll
+IMPORTS = vcomp100
+
+C_SRCS = \
+	main.c \
+	atomic.c
+
+@MAKE_TEST_RULES@
diff --git a/dlls/vcomp100/tests/atomic.c b/dlls/vcomp100/tests/atomic.c
new file mode 100644
index 0000000..3b1df44
--- /dev/null
+++ b/dlls/vcomp100/tests/atomic.c
@@ -0,0 +1,81 @@
+/*
+ * Unit test suite for vcomp functions.
+ *
+ * Copyright 2012 Dan Kegel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "wine/test.h"
+#include <stdio.h>
+
+static void test_atomic_add(void)
+{
+#if 1
+    CHAR i1;
+    INT16 i2;
+    INT32 i4;
+    INT64 i8;
+    float r4;
+    double r8;
+
+    /* FIXME: should these be in some private header? */
+    void CDECL _vcomp_atomic_add_i1(char  *p, short  val);
+    void CDECL _vcomp_atomic_add_i2(short  *p, short  val);
+    void CDECL _vcomp_atomic_add_i4(int    *p, int    val);
+    void CDECL _vcomp_atomic_add_i8(INT64  *p, INT64  val);
+    void CDECL _vcomp_atomic_add_r4(float  *p, float  val);
+    void CDECL _vcomp_atomic_add_r8(double *p, double val);
+
+    i1 = 0;
+    _vcomp_atomic_add_i1(&i1, 1);
+    ok(i1 == 1, "1 + 1 == 1\n");
+    i1 = 0x7f;
+    _vcomp_atomic_add_i1(&i1, 1);
+    ok((0xff & i1) == 0x80, "0x7f + 1 == 0x80 was 0x%x\n", (0xff & i1));
+
+    i2 = 0;
+    _vcomp_atomic_add_i2(&i2, 1);
+    ok(i2 == 1, "1 + 1 == 1\n");
+    i2 = 0x7fff;
+    _vcomp_atomic_add_i2(&i2, 1);
+    ok((0xffff & i2) == 0x8000, "0x7fff + 1 == 0x8000, was 0x%x\n", (0xffff & i2));
+
+    i4 = 0;
+    _vcomp_atomic_add_i4(&i4, 1);
+    ok(i4 == 1, "1 + 1 == 1\n");
+    i4 = 0x7fffffffU;
+    _vcomp_atomic_add_i4(&i4, 1);
+    ok((0xffffffff & i4) == 0x80000000, "0x7fffffff + 1 == 0x8000000, was 0x%x\n", (0xffffffff & i4));
+
+    i8 = 0;
+    _vcomp_atomic_add_i8(&i8, 1);
+    ok(i8 == 1, "1 + 1 == 1\n");
+#if _WIN64
+    i8 = 0x7fffffffffffffffL;
+    _vcomp_atomic_add_i8(&i8, 1);
+    ok(i8 == 0x8000000000000000L, "0x7fffffffffffffffL + 1 == 0x8000000000000000L, was 0x%lx\n", i8);
+#else
+    i8 = 0x7fffffffffffffffLL;
+    _vcomp_atomic_add_i8(&i8, 1);
+    ok(i8 == 0x8000000000000000LL, "0x7fffffffffffffffLL + 1 == 0x8000000000000000LL, was 0x%lx\n", i8);
+#endif
+#endif
+}
+
+START_TEST(atomic)
+{
+    test_atomic_add();
+}
diff --git a/dlls/vcomp100/tests/main.c b/dlls/vcomp100/tests/main.c
new file mode 100644
index 0000000..f496410
--- /dev/null
+++ b/dlls/vcomp100/tests/main.c
@@ -0,0 +1,182 @@
+/*
+ * Unit test suite for vcomp functions.
+ *
+ * Copyright 2012 Dan Kegel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "wine/test.h"
+#include <stdio.h>
+
+/* FIXME: should be in omp.h */
+void CDECL omp_set_num_threads(int);
+int CDECL omp_get_max_threads(void);
+int CDECL omp_get_num_threads(void);
+int CDECL omp_get_thread_num(void);
+int CDECL omp_get_num_procs(void);
+int CDECL omp_in_parallel(void);
+
+/* Should we have a private vcomp.h? */
+//void WINAPIV _vcomp_fork(DWORD, DWORD, void (__cdecl *)(__ms_va_list), ...);
+void WINAPIV _vcomp_fork(DWORD, DWORD, void *, ...);
+void CDECL _vcomp_for_static_simple_init(int first, int last, int mystep, int step, int *pfirst, int *plast);
+void CDECL _vcomp_for_static_end(void);
+int CDECL _vcomp_for_dynamic_next(int *pcounter, int *plimit);
+void CDECL _vcomp_for_dynamic_init(int flags, int first, int last, int mystep, int chunksize);
+void CDECL _vcomp_atomic_add_i4(int    *p, int    val);
+
+void test_omp_get_num_threads(void)
+{
+    int nt = omp_get_num_threads();
+    ok(nt == 1, "omp_get_num_threads() outside parallel was %d, but should be 1\n", nt);
+}
+
+void test_omp_get_max_threads(void)
+{
+    int mt = omp_get_max_threads();
+    ok(mt >= 1, "omp_get_max_threads() was %d, but should be at least 1\n", mt);
+}
+
+void test_omp_get_thread_num(void)
+{
+    int tnum;
+    tnum = omp_get_thread_num();
+    ok(tnum == 0, "omp_get_thread_num() outside parallel was %d, but should be 0\n", tnum);
+}
+
+void test_omp_get_num_procs(void)
+{
+    int np = omp_get_num_procs();
+    ok(np >= 1, "omp_get_num_procs() outside parallel was %d, but should be >= 1\n", np);
+}
+
+void test_omp_in_parallel(void)
+{
+    int ip = omp_in_parallel();
+    ok(ip == 0, "omp_in_parallel() outside parallel was %d, but should be 0\n", ip);
+}
+
+LONG volatile ncalls;
+
+void workerfunc1(int a, int b, int c, int d)
+{
+    ok(a == 1, "expected a == 1, got %d\n", a);
+    ok(b == 2, "expected b == 2, got %d\n", b);
+    ok(c == 3, "expected c == 3, got %d\n", c);
+    ok(d == 4, "expedted d == 4, got %d\n", d);
+    InterlockedIncrement(&ncalls);
+}
+
+void workerfunc2(LONG volatile *p)
+{
+    printf("in workerfunc2\n");
+    InterlockedIncrement(p);
+}
+
+void test_vcomp_fork(void)
+{
+    ncalls = 0;
+    _vcomp_fork(0, 4, workerfunc1, 1, 2, 3, 4);
+    printf("with parallel=0, ncalls is %d\n", ncalls);
+    ok(ncalls == 1, "expected 1 call, got %d\n", ncalls);
+
+    ncalls = 0;
+    _vcomp_fork(1, 4, workerfunc1, 1, 2, 3, 4);
+    printf("with parallel=1, ncalls is %d\n", ncalls);
+    ok(ncalls >= 1, "expected >= 1 call, got %d\n", ncalls);
+
+    ncalls = 0;
+    _vcomp_fork(0, 1, workerfunc2, &ncalls);
+    printf("with parallel=0, ncalls is %d\n", ncalls);
+    ok(ncalls == 1, "expected 1 call, got %d\n", ncalls);
+}
+
+LONG nsum;
+
+void worker_simple_for(void)
+{
+    int i, my_limit;
+
+    InterlockedIncrement(&ncalls);
+
+    /* for (i=0; i<=12; i++) */
+    _vcomp_for_static_simple_init(0, 12, 1, 1, &i, &my_limit);
+
+    printf("i is %d, my_limit is %d\n", i, my_limit);
+    while (i <= my_limit) {
+        _vcomp_atomic_add_i4(&nsum, i);
+        i++;
+    }
+
+    printf("Loop is done, nsum is %d\n", nsum);
+    _vcomp_for_static_end();
+}
+
+void test_simple_for(void)
+{
+    ncalls = 0;
+    nsum = 0;
+    _vcomp_fork(1, 0, worker_simple_for);
+    printf("with parallel=1, ncalls is %d, nsum is %d\n", ncalls, nsum);
+    ok(ncalls >= 1, "expected >= 1 call, got %d\n", ncalls);
+    ok(nsum == 6*13, "expected sum 6*13, got %d\n", nsum);
+}
+
+void worker_dynamic_for(void)
+{
+    int i, limit;
+
+    InterlockedIncrement(&ncalls);
+
+    /* pragma omp schedule(dynamic,16) */
+    /* for (i=0; i<=17; i++) */
+    _vcomp_for_dynamic_init(98, 0, 17, 1, 16);
+
+    printf("top of loop\n");
+    while (_vcomp_for_dynamic_next(&i, &limit)) {
+        for (; i<=limit; i++) {
+            printf("i is %d, limit is %d\n", i, limit);
+            _vcomp_atomic_add_i4(&nsum, i);
+        }
+    }
+
+    printf("Loop is done, nsum is %d\n", nsum);
+}
+
+void test_dynamic_for(void)
+{
+    ncalls = 0;
+    nsum = 0;
+    _vcomp_fork(1, 0, worker_dynamic_for);
+    printf("with parallel=1, ncalls is %d, nsum is %d\n", ncalls, nsum);
+    ok(ncalls >= 1, "expected >= 1 call, got %d\n", ncalls);
+    ok(nsum == 9*17, "expected sum 9*17, got %d\n", nsum);
+}
+
+START_TEST(main)
+{
+    printf("Starting test\n");
+    test_omp_get_num_threads();
+    test_omp_get_max_threads();
+    test_omp_get_thread_num();
+    test_omp_get_num_procs();
+    test_omp_in_parallel();
+    test_vcomp_fork();
+    test_simple_for();
+    test_dynamic_for();
+
+    printf("Main test over.\n");
+}
diff --git a/dlls/vcomp100/vcomp100.spec b/dlls/vcomp100/vcomp100.spec
index cd5a964..5e0f221 100644
--- a/dlls/vcomp100/vcomp100.spec
+++ b/dlls/vcomp100/vcomp100.spec
@@ -1,33 +1,33 @@
-@ stub _vcomp_atomic_add_i1
-@ stub _vcomp_atomic_add_i2
-@ stub _vcomp_atomic_add_i4
-@ stub _vcomp_atomic_add_i8
-@ stub _vcomp_atomic_add_r4
-@ stub _vcomp_atomic_add_r8
-@ stub _vcomp_atomic_and_i1
-@ stub _vcomp_atomic_and_i2
-@ stub _vcomp_atomic_and_i4
-@ stub _vcomp_atomic_and_i8
-@ stub _vcomp_atomic_div_i1
-@ stub _vcomp_atomic_div_i2
-@ stub _vcomp_atomic_div_i4
-@ stub _vcomp_atomic_div_i8
-@ stub _vcomp_atomic_div_r4
-@ stub _vcomp_atomic_div_r8
+@ cdecl _vcomp_atomic_add_i1(ptr long) vcomp._vcomp_atomic_add_i1
+@ cdecl _vcomp_atomic_add_i2(ptr long) vcomp._vcomp_atomic_add_i2
+@ cdecl _vcomp_atomic_add_i4(ptr long) vcomp._vcomp_atomic_add_i4
+@ cdecl _vcomp_atomic_add_i8(ptr int64) vcomp._vcomp_atomic_add_i8
+@ cdecl _vcomp_atomic_add_r4(ptr float) vcomp._vcomp_atomic_add_r4
+@ cdecl _vcomp_atomic_add_r8(ptr double) vcomp._vcomp_atomic_add_r8
+@ cdecl _vcomp_atomic_and_i1(ptr long) vcomp._vcomp_atomic_and_i1
+@ cdecl _vcomp_atomic_and_i2(ptr long) vcomp._vcomp_atomic_and_i2
+@ cdecl _vcomp_atomic_and_i4(ptr long) vcomp._vcomp_atomic_and_i4
+@ cdecl _vcomp_atomic_and_i8(ptr int64) vcomp._vcomp_atomic_and_i8
+@ cdecl _vcomp_atomic_div_i1(ptr long) vcomp._vcomp_atomic_div_i1
+@ cdecl _vcomp_atomic_div_i2(ptr long) vcomp._vcomp_atomic_div_i2
+@ cdecl _vcomp_atomic_div_i4(ptr long) vcomp._vcomp_atomic_div_i4
+@ cdecl _vcomp_atomic_div_i8(ptr int64) vcomp._vcomp_atomic_div_i8
+@ cdecl _vcomp_atomic_div_r4(ptr float) vcomp._vcomp_atomic_div_r4
+@ cdecl _vcomp_atomic_div_r8(ptr double) vcomp._vcomp_atomic_div_r8
 @ stub _vcomp_atomic_div_ui1
 @ stub _vcomp_atomic_div_ui2
 @ stub _vcomp_atomic_div_ui4
 @ stub _vcomp_atomic_div_ui8
-@ stub _vcomp_atomic_mul_i1
-@ stub _vcomp_atomic_mul_i2
-@ stub _vcomp_atomic_mul_i4
-@ stub _vcomp_atomic_mul_i8
-@ stub _vcomp_atomic_mul_r4
-@ stub _vcomp_atomic_mul_r8
-@ stub _vcomp_atomic_or_i1
-@ stub _vcomp_atomic_or_i2
-@ stub _vcomp_atomic_or_i4
-@ stub _vcomp_atomic_or_i8
+@ cdecl _vcomp_atomic_mul_i1(ptr long) vcomp._vcomp_atomic_mul_i1
+@ cdecl _vcomp_atomic_mul_i2(ptr long) vcomp._vcomp_atomic_mul_i2
+@ cdecl _vcomp_atomic_mul_i4(ptr long) vcomp._vcomp_atomic_mul_i4
+@ cdecl _vcomp_atomic_mul_i8(ptr int64) vcomp._vcomp_atomic_mul_i8
+@ cdecl _vcomp_atomic_mul_r4(ptr float) vcomp._vcomp_atomic_mul_r4
+@ cdecl _vcomp_atomic_mul_r8(ptr double) vcomp._vcomp_atomic_mul_r8
+@ cdecl _vcomp_atomic_or_i1(ptr long) vcomp._vcomp_atomic_or_i1
+@ cdecl _vcomp_atomic_or_i2(ptr long) vcomp._vcomp_atomic_or_i2
+@ cdecl _vcomp_atomic_or_i4(ptr long) vcomp._vcomp_atomic_or_i4
+@ cdecl _vcomp_atomic_or_i8(ptr int64) vcomp._vcomp_atomic_or_i8
 @ stub _vcomp_atomic_shl_i1
 @ stub _vcomp_atomic_shl_i2
 @ stub _vcomp_atomic_shl_i4
@@ -40,36 +40,36 @@
 @ stub _vcomp_atomic_shr_ui2
 @ stub _vcomp_atomic_shr_ui4
 @ stub _vcomp_atomic_shr_ui8
-@ stub _vcomp_atomic_sub_i1
-@ stub _vcomp_atomic_sub_i2
-@ stub _vcomp_atomic_sub_i4
-@ stub _vcomp_atomic_sub_i8
-@ stub _vcomp_atomic_sub_r4
-@ stub _vcomp_atomic_sub_r8
-@ stub _vcomp_atomic_xor_i1
-@ stub _vcomp_atomic_xor_i2
-@ stub _vcomp_atomic_xor_i4
-@ stub _vcomp_atomic_xor_i8
-@ stub _vcomp_barrier
+@ cdecl _vcomp_atomic_sub_i1(ptr long) vcomp._vcomp_atomic_sub_i1
+@ cdecl _vcomp_atomic_sub_i2(ptr long) vcomp._vcomp_atomic_sub_i2
+@ cdecl _vcomp_atomic_sub_i4(ptr long) vcomp._vcomp_atomic_sub_i4
+@ cdecl _vcomp_atomic_sub_i8(ptr int64) vcomp._vcomp_atomic_sub_i8
+@ cdecl _vcomp_atomic_sub_r4(ptr float) vcomp._vcomp_atomic_sub_r4
+@ cdecl _vcomp_atomic_sub_r8(ptr double) vcomp._vcomp_atomic_sub_r8
+@ cdecl _vcomp_atomic_xor_i1(ptr long) vcomp._vcomp_atomic_xor_i1
+@ cdecl _vcomp_atomic_xor_i2(ptr long) vcomp._vcomp_atomic_xor_i2
+@ cdecl _vcomp_atomic_xor_i4(ptr long) vcomp._vcomp_atomic_xor_i4
+@ cdecl _vcomp_atomic_xor_i8(ptr int64) vcomp._vcomp_atomic_xor_i8
+@ cdecl _vcomp_barrier() vcomp._vcomp_barrier
 @ stub _vcomp_copyprivate_broadcast
 @ stub _vcomp_copyprivate_receive
-@ stub _vcomp_enter_critsect
+@ cdecl _vcomp_enter_critsect(ptr) vcomp._vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr) vcomp._vcomp_for_dynamic_next
 @ stub _vcomp_for_dynamic_next_i8
-@ stub _vcomp_for_static_end
+@ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
 @ stub _vcomp_for_static_init
 @ stub _vcomp_for_static_init_i8
-@ stub _vcomp_for_static_simple_init
+@ cdecl _vcomp_for_static_simple_init(long long long long ptr ptr) vcomp._vcomp_for_static_simple_init
 @ stub _vcomp_for_static_simple_init_i8
-@ stub _vcomp_fork
+@ varargs _vcomp_fork(long long ptr) vcomp._vcomp_fork
 @ stub _vcomp_get_thread_num
-@ stub _vcomp_leave_critsect
+@ cdecl _vcomp_leave_critsect(ptr) vcomp._vcomp_leave_critsect
 @ stub _vcomp_master_barrier
-@ stub _vcomp_master_begin
-@ stub _vcomp_master_end
+@ cdecl _vcomp_master_begin() vcomp._vcomp_master_begin
+@ cdecl _vcomp_master_end() vcomp._vcomp_master_end
 @ stub _vcomp_ordered_begin
 @ stub _vcomp_ordered_end
 @ stub _vcomp_ordered_loop_end
@@ -83,30 +83,30 @@
 @ stub _vcomp_reduction_u2
 @ stub _vcomp_reduction_u4
 @ stub _vcomp_reduction_u8
-@ stub _vcomp_sections_init
-@ stub _vcomp_sections_next
-@ stub _vcomp_set_num_threads
-@ stub _vcomp_single_begin
-@ stub _vcomp_single_end
-@ stub omp_destroy_lock
-@ stub omp_destroy_nest_lock
-@ stub omp_get_dynamic
-@ stub omp_get_max_threads
-@ stub omp_get_nested
-@ stub omp_get_num_procs
-@ stub omp_get_num_threads
-@ stub omp_get_thread_num
-@ stub omp_get_wtick
-@ stub omp_get_wtime
-@ stub omp_in_parallel
-@ stub omp_init_lock
-@ stub omp_init_nest_lock
-@ stub omp_set_dynamic
-@ stub omp_set_lock
-@ stub omp_set_nest_lock
-@ stub omp_set_nested
-@ stub omp_set_num_threads
-@ stub omp_test_lock
-@ stub omp_test_nest_lock
-@ stub omp_unset_lock
-@ stub omp_unset_nest_lock
+@ cdecl _vcomp_sections_init(long) vcomp._vcomp_sections_init
+@ cdecl _vcomp_sections_next() vcomp._vcomp_sections_next
+@ cdecl _vcomp_set_num_threads(long) vcomp._vcomp_set_num_threads
+@ cdecl _vcomp_single_begin(long) vcomp._vcomp_single_begin
+@ cdecl _vcomp_single_end() vcomp._vcomp_single_end
+@ cdecl omp_destroy_lock(ptr) vcomp.omp_destroy_lock
+@ cdecl omp_destroy_nest_lock(ptr) vcomp.omp_destroy_nest_lock
+@ cdecl omp_get_dynamic() vcomp.omp_get_dynamic
+@ cdecl omp_get_max_threads() vcomp.omp_get_max_threads
+@ cdecl omp_get_nested() vcomp.omp_get_nested
+@ cdecl omp_get_num_procs() vcomp.omp_get_num_procs
+@ cdecl omp_get_num_threads() vcomp.omp_get_num_threads
+@ cdecl omp_get_thread_num() vcomp.omp_get_thread_num
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
+@ cdecl omp_get_wtime() vcomp.omp_get_wtime
+@ cdecl omp_in_parallel() vcomp.omp_in_parallel
+@ cdecl omp_init_lock(ptr) vcomp.omp_init_lock
+@ cdecl omp_init_nest_lock(ptr) vcomp.omp_init_nest_lock
+@ cdecl omp_set_dynamic(long) vcomp.omp_set_dynamic
+@ cdecl omp_set_lock(ptr) vcomp.omp_set_lock
+@ cdecl omp_set_nest_lock(ptr) vcomp.omp_set_nest_lock
+@ cdecl omp_set_nested(long) vcomp.omp_set_nested
+@ cdecl omp_set_num_threads(long) vcomp.omp_set_num_threads
+@ cdecl omp_test_lock(ptr) vcomp.omp_test_lock
+@ cdecl omp_test_nest_lock(ptr) vcomp.omp_test_nest_lock
+@ cdecl omp_unset_lock(ptr) vcomp.omp_unset_lock
+@ cdecl omp_unset_nest_lock(ptr) vcomp.omp_unset_nest_lock
diff --git a/dlls/vcomp90/Makefile.in b/dlls/vcomp90/Makefile.in
new file mode 100644
index 0000000..48dafbd
--- /dev/null
+++ b/dlls/vcomp90/Makefile.in
@@ -0,0 +1,6 @@
+MODULE = vcomp90.dll
+
+C_SRCS = \
+	main.c
+
+@MAKE_DLL_RULES@
diff --git a/dlls/vcomp90/main.c b/dlls/vcomp90/main.c
new file mode 100644
index 0000000..58a62d4
--- /dev/null
+++ b/dlls/vcomp90/main.c
@@ -0,0 +1,48 @@
+/*
+ *
+ * vcomp90 implementation
+ *
+ * Copyright 2012 Andr√© Hentschel
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(vcomp);
+
+BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+{
+    TRACE("(0x%p, %d, %p)\n", hinstDLL, fdwReason, lpvReserved);
+
+    switch (fdwReason)
+    {
+        case DLL_WINE_PREATTACH:
+            return FALSE;    /* prefer native version */
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls(hinstDLL);
+            break;
+        case DLL_PROCESS_DETACH:
+            break;
+    }
+
+    return TRUE;
+}
diff --git a/dlls/vcomp90/vcomp90.spec b/dlls/vcomp90/vcomp90.spec
new file mode 100644
index 0000000..5e0f221
--- /dev/null
+++ b/dlls/vcomp90/vcomp90.spec
@@ -0,0 +1,112 @@
+@ cdecl _vcomp_atomic_add_i1(ptr long) vcomp._vcomp_atomic_add_i1
+@ cdecl _vcomp_atomic_add_i2(ptr long) vcomp._vcomp_atomic_add_i2
+@ cdecl _vcomp_atomic_add_i4(ptr long) vcomp._vcomp_atomic_add_i4
+@ cdecl _vcomp_atomic_add_i8(ptr int64) vcomp._vcomp_atomic_add_i8
+@ cdecl _vcomp_atomic_add_r4(ptr float) vcomp._vcomp_atomic_add_r4
+@ cdecl _vcomp_atomic_add_r8(ptr double) vcomp._vcomp_atomic_add_r8
+@ cdecl _vcomp_atomic_and_i1(ptr long) vcomp._vcomp_atomic_and_i1
+@ cdecl _vcomp_atomic_and_i2(ptr long) vcomp._vcomp_atomic_and_i2
+@ cdecl _vcomp_atomic_and_i4(ptr long) vcomp._vcomp_atomic_and_i4
+@ cdecl _vcomp_atomic_and_i8(ptr int64) vcomp._vcomp_atomic_and_i8
+@ cdecl _vcomp_atomic_div_i1(ptr long) vcomp._vcomp_atomic_div_i1
+@ cdecl _vcomp_atomic_div_i2(ptr long) vcomp._vcomp_atomic_div_i2
+@ cdecl _vcomp_atomic_div_i4(ptr long) vcomp._vcomp_atomic_div_i4
+@ cdecl _vcomp_atomic_div_i8(ptr int64) vcomp._vcomp_atomic_div_i8
+@ cdecl _vcomp_atomic_div_r4(ptr float) vcomp._vcomp_atomic_div_r4
+@ cdecl _vcomp_atomic_div_r8(ptr double) vcomp._vcomp_atomic_div_r8
+@ stub _vcomp_atomic_div_ui1
+@ stub _vcomp_atomic_div_ui2
+@ stub _vcomp_atomic_div_ui4
+@ stub _vcomp_atomic_div_ui8
+@ cdecl _vcomp_atomic_mul_i1(ptr long) vcomp._vcomp_atomic_mul_i1
+@ cdecl _vcomp_atomic_mul_i2(ptr long) vcomp._vcomp_atomic_mul_i2
+@ cdecl _vcomp_atomic_mul_i4(ptr long) vcomp._vcomp_atomic_mul_i4
+@ cdecl _vcomp_atomic_mul_i8(ptr int64) vcomp._vcomp_atomic_mul_i8
+@ cdecl _vcomp_atomic_mul_r4(ptr float) vcomp._vcomp_atomic_mul_r4
+@ cdecl _vcomp_atomic_mul_r8(ptr double) vcomp._vcomp_atomic_mul_r8
+@ cdecl _vcomp_atomic_or_i1(ptr long) vcomp._vcomp_atomic_or_i1
+@ cdecl _vcomp_atomic_or_i2(ptr long) vcomp._vcomp_atomic_or_i2
+@ cdecl _vcomp_atomic_or_i4(ptr long) vcomp._vcomp_atomic_or_i4
+@ cdecl _vcomp_atomic_or_i8(ptr int64) vcomp._vcomp_atomic_or_i8
+@ stub _vcomp_atomic_shl_i1
+@ stub _vcomp_atomic_shl_i2
+@ stub _vcomp_atomic_shl_i4
+@ stub _vcomp_atomic_shl_i8
+@ stub _vcomp_atomic_shr_i1
+@ stub _vcomp_atomic_shr_i2
+@ stub _vcomp_atomic_shr_i4
+@ stub _vcomp_atomic_shr_i8
+@ stub _vcomp_atomic_shr_ui1
+@ stub _vcomp_atomic_shr_ui2
+@ stub _vcomp_atomic_shr_ui4
+@ stub _vcomp_atomic_shr_ui8
+@ cdecl _vcomp_atomic_sub_i1(ptr long) vcomp._vcomp_atomic_sub_i1
+@ cdecl _vcomp_atomic_sub_i2(ptr long) vcomp._vcomp_atomic_sub_i2
+@ cdecl _vcomp_atomic_sub_i4(ptr long) vcomp._vcomp_atomic_sub_i4
+@ cdecl _vcomp_atomic_sub_i8(ptr int64) vcomp._vcomp_atomic_sub_i8
+@ cdecl _vcomp_atomic_sub_r4(ptr float) vcomp._vcomp_atomic_sub_r4
+@ cdecl _vcomp_atomic_sub_r8(ptr double) vcomp._vcomp_atomic_sub_r8
+@ cdecl _vcomp_atomic_xor_i1(ptr long) vcomp._vcomp_atomic_xor_i1
+@ cdecl _vcomp_atomic_xor_i2(ptr long) vcomp._vcomp_atomic_xor_i2
+@ cdecl _vcomp_atomic_xor_i4(ptr long) vcomp._vcomp_atomic_xor_i4
+@ cdecl _vcomp_atomic_xor_i8(ptr int64) vcomp._vcomp_atomic_xor_i8
+@ cdecl _vcomp_barrier() vcomp._vcomp_barrier
+@ stub _vcomp_copyprivate_broadcast
+@ stub _vcomp_copyprivate_receive
+@ cdecl _vcomp_enter_critsect(ptr) vcomp._vcomp_enter_critsect
+@ stub _vcomp_flush
+@ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
+@ stub _vcomp_for_dynamic_init_i8
+@ cdecl _vcomp_for_dynamic_next(ptr) vcomp._vcomp_for_dynamic_next
+@ stub _vcomp_for_dynamic_next_i8
+@ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
+@ stub _vcomp_for_static_init
+@ stub _vcomp_for_static_init_i8
+@ cdecl _vcomp_for_static_simple_init(long long long long ptr ptr) vcomp._vcomp_for_static_simple_init
+@ stub _vcomp_for_static_simple_init_i8
+@ varargs _vcomp_fork(long long ptr) vcomp._vcomp_fork
+@ stub _vcomp_get_thread_num
+@ cdecl _vcomp_leave_critsect(ptr) vcomp._vcomp_leave_critsect
+@ stub _vcomp_master_barrier
+@ cdecl _vcomp_master_begin() vcomp._vcomp_master_begin
+@ cdecl _vcomp_master_end() vcomp._vcomp_master_end
+@ stub _vcomp_ordered_begin
+@ stub _vcomp_ordered_end
+@ stub _vcomp_ordered_loop_end
+@ stub _vcomp_reduction_i1
+@ stub _vcomp_reduction_i2
+@ stub _vcomp_reduction_i4
+@ stub _vcomp_reduction_i8
+@ stub _vcomp_reduction_r4
+@ stub _vcomp_reduction_r8
+@ stub _vcomp_reduction_u1
+@ stub _vcomp_reduction_u2
+@ stub _vcomp_reduction_u4
+@ stub _vcomp_reduction_u8
+@ cdecl _vcomp_sections_init(long) vcomp._vcomp_sections_init
+@ cdecl _vcomp_sections_next() vcomp._vcomp_sections_next
+@ cdecl _vcomp_set_num_threads(long) vcomp._vcomp_set_num_threads
+@ cdecl _vcomp_single_begin(long) vcomp._vcomp_single_begin
+@ cdecl _vcomp_single_end() vcomp._vcomp_single_end
+@ cdecl omp_destroy_lock(ptr) vcomp.omp_destroy_lock
+@ cdecl omp_destroy_nest_lock(ptr) vcomp.omp_destroy_nest_lock
+@ cdecl omp_get_dynamic() vcomp.omp_get_dynamic
+@ cdecl omp_get_max_threads() vcomp.omp_get_max_threads
+@ cdecl omp_get_nested() vcomp.omp_get_nested
+@ cdecl omp_get_num_procs() vcomp.omp_get_num_procs
+@ cdecl omp_get_num_threads() vcomp.omp_get_num_threads
+@ cdecl omp_get_thread_num() vcomp.omp_get_thread_num
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
+@ cdecl omp_get_wtime() vcomp.omp_get_wtime
+@ cdecl omp_in_parallel() vcomp.omp_in_parallel
+@ cdecl omp_init_lock(ptr) vcomp.omp_init_lock
+@ cdecl omp_init_nest_lock(ptr) vcomp.omp_init_nest_lock
+@ cdecl omp_set_dynamic(long) vcomp.omp_set_dynamic
+@ cdecl omp_set_lock(ptr) vcomp.omp_set_lock
+@ cdecl omp_set_nest_lock(ptr) vcomp.omp_set_nest_lock
+@ cdecl omp_set_nested(long) vcomp.omp_set_nested
+@ cdecl omp_set_num_threads(long) vcomp.omp_set_num_threads
+@ cdecl omp_test_lock(ptr) vcomp.omp_test_lock
+@ cdecl omp_test_nest_lock(ptr) vcomp.omp_test_nest_lock
+@ cdecl omp_unset_lock(ptr) vcomp.omp_unset_lock
+@ cdecl omp_unset_nest_lock(ptr) vcomp.omp_unset_nest_lock
